//# Почему Redux Toolkit — это как использовать Redux сегодня
// Redux Toolkit (также известный как «RTK» для краткости) — это наш официальный рекомендуемый подход для написания логики Redux. Пакет @reduxjs/toolkit окружает основной redux пакет и содержит методы API и общие зависимости, которые, по нашему мнению, необходимы для создания приложения Redux. Redux Toolkit использует предложенные нами лучшие практики, упрощает большинство задач Redux, предотвращает распространенные ошибки и упрощает написание приложений Redux.

// RTK включает в себя утилиты, которые помогают упростить многие распространенные случаи использования, включая настройку хранилища, создание редьюсеров и написание неизменяемой логики обновления и даже одновременное создание целых «срезов» состояния.

// Независимо от того, являетесь ли вы новым пользователем Redux, настраивающим свой первый проект, или опытным пользователем, желающим упростить существующее приложение, Redux Toolkit поможет вам улучшить ваш код Redux.

//* Заметка
/* См. эти страницы, чтобы узнать, как использовать «современный Redux» с Redux Toolkit:
- Учебник «Redux Essentials», в котором рассказывается, «как правильно использовать Redux» с Redux Toolkit для реальных приложений, https://redux.js.org/tutorials/essentials/part-1-overview-concepts
- Основы Redux, часть 8: Современный Redux с Redux Toolkit, в котором показано, как преобразовать низкоуровневые примеры из предыдущих разделов руководства в современные эквиваленты Redux Toolkit.
https://redux.js.org/tutorials/fundamentals/part-8-modern-redux
- Использование Redux: переход на Modern Redux, в котором рассказывается, как перенести различные виды устаревшей логики Redux в современные эквиваленты Redux.
https://redux.js.org/usage/migrating-to-modern-redux
*/
//* Заметка

//# Чем Redux Toolkit отличается от ядра Redux

//# Что такое Redux?
// Первое, что нужно спросить: «Что такое Redux?»

/* Redux на самом деле:
- Единственное хранилище, содержащее «глобальное» состояние.
- Отправка действий с простым объектом в хранилище, когда что-то происходит в приложении.
- Чистые функции редуктора, просматривающие эти действия и возвращающие неизменно обновленное состояние.
*/

/* Хотя это и не обязательно, ваш код Redux обычно включает в себя:
- Создатели действий, которые генерируют эти объекты действий.
- Промежуточное ПО для включения побочных эффектов
- Функции Thunk, содержащие синхронную или асинхронную логику с побочными эффектами.
- Нормализованное состояние, позволяющее искать элементы по идентификатору.
- Мемоизированные функции выбора с библиотекой Reselect для оптимизации производных данных.
- Расширение Redux DevTools для просмотра истории ваших действий и изменений состояния.
- Типы TypeScript для действий, состояния и других функций
*/

// Кроме того, Redux обычно используется с библиотекой React-Redux, чтобы ваши компоненты React могли взаимодействовать с хранилищем Redux.

//# Что делает ядро ​​Redux?
/* Ядро Redux — очень маленькая и намеренно некомпетентная библиотека. Он предоставляет несколько небольших примитивов API:
- createStore для создания хранилища Redux
- combineReducers для объединения нескольких reducers в один более крупный reducer
- applyMiddleware для объединения нескольких middleware в store enhancers
- сompose для объединения нескольких enhancers в один enhancers.
*/

// Помимо этого, вся остальная логика, связанная с Redux, в вашем приложении должна быть полностью написана вами.

// Хорошей новостью является то, что это означает, что Redux можно использовать по-разному. Плохая новость заключается в том, что нет помощников, которые могли бы облегчить написание вашего кода.

// Например, функция редуктора — это просто функция. До Redux Toolkit вы обычно писали этот reducer с оператором переключения и обновлениями вручную. У вас также, вероятно, будут рукописные создатели действий и константы типов действий:

const ADD_TODO = 'ADD_TODO';
const TODO_TOGGLED = 'TODO_TOGGLED';

export const addTodo = text => ({
  type: ADD_TODO,
  payload: { text, id: nanoid() },
});

export const todoToggled = id => ({
  type: TODO_TOGGLED,
  payload: { id },
});

export const todosReducer = (state = [], action) => {
  switch (action.type) {
    case ADD_TODO:
      return state.concat({
        id: action.payload.id,
        text: action.payload.text,
        completed: false,
      });
    case TODO_TOGGLED:
      return state.map(todo => {
        if (todo.id !== action.payload.id) return todo;

        return {
          ...todo,
          completed: !todo.completed,
        };
      });
    default:
      return state;
  }
};

// Ни один из этих кодов конкретно не зависит от какого-либо API из redux основной библиотеки. Но нужно написать много кода. Неизменяемые обновления требовали большого количества рукописных расширений объектов и операций с массивами, и было очень легко допустить ошибки и случайно изменить состояние в процессе (всегда причина №1 ошибок Redux!). Также было обычным, хотя и не строго обязательным, распределять код одной функции по нескольким файлам, таким как actions/todos.js, constants/todos.jsи reducers/todos.js.

// Кроме того, настройка магазина обычно требовала ряда шагов для добавления часто используемого промежуточного программного обеспечения, такого как thunks, и включения поддержки расширения Redux DevTools Extension, хотя это стандартные инструменты, используемые почти в каждом приложении Redux.

//# Что делает Redux Toolkit?
