//# Почему Redux Toolkit — это как использовать Redux сегодня
// Redux Toolkit (также известный как «RTK» для краткости) — это наш официальный рекомендуемый подход для написания логики Redux. Пакет @reduxjs/toolkit окружает основной redux пакет и содержит методы API и общие зависимости, которые, по нашему мнению, необходимы для создания приложения Redux. Redux Toolkit использует предложенные нами лучшие практики, упрощает большинство задач Redux, предотвращает распространенные ошибки и упрощает написание приложений Redux.

// RTK включает в себя утилиты, которые помогают упростить многие распространенные случаи использования, включая настройку хранилища, создание редьюсеров и написание неизменяемой логики обновления и даже одновременное создание целых «срезов» состояния.

// Независимо от того, являетесь ли вы новым пользователем Redux, настраивающим свой первый проект, или опытным пользователем, желающим упростить существующее приложение, Redux Toolkit поможет вам улучшить ваш код Redux.

//* Заметка
/* См. эти страницы, чтобы узнать, как использовать «современный Redux» с Redux Toolkit:
- Учебник «Redux Essentials», в котором рассказывается, «как правильно использовать Redux» с Redux Toolkit для реальных приложений, https://redux.js.org/tutorials/essentials/part-1-overview-concepts
- Основы Redux, часть 8: Современный Redux с Redux Toolkit, в котором показано, как преобразовать низкоуровневые примеры из предыдущих разделов руководства в современные эквиваленты Redux Toolkit.
https://redux.js.org/tutorials/fundamentals/part-8-modern-redux
- Использование Redux: переход на Modern Redux, в котором рассказывается, как перенести различные виды устаревшей логики Redux в современные эквиваленты Redux.
https://redux.js.org/usage/migrating-to-modern-redux
*/
//* Заметка

//# Чем Redux Toolkit отличается от ядра Redux

//# Что такое Redux?
// Первое, что нужно спросить: «Что такое Redux?»

/* Redux на самом деле:
- Единственное хранилище, содержащее «глобальное» состояние.
- Отправка действий с простым объектом в хранилище, когда что-то происходит в приложении.
- Чистые функции редуктора, просматривающие эти действия и возвращающие неизменно обновленное состояние.
*/

/* Хотя это и не обязательно, ваш код Redux обычно включает в себя:
- Создатели действий, которые генерируют эти объекты действий.
- Промежуточное ПО для включения побочных эффектов
- Функции Thunk, содержащие синхронную или асинхронную логику с побочными эффектами.
- Нормализованное состояние, позволяющее искать элементы по идентификатору.
- Мемоизированные функции выбора с библиотекой Reselect для оптимизации производных данных.
- Расширение Redux DevTools для просмотра истории ваших действий и изменений состояния.
- Типы TypeScript для действий, состояния и других функций
*/

// Кроме того, Redux обычно используется с библиотекой React-Redux, чтобы ваши компоненты React могли взаимодействовать с хранилищем Redux.

//# Что делает ядро ​​Redux?
/* Ядро Redux — очень маленькая и намеренно некомпетентная библиотека. Он предоставляет несколько небольших примитивов API:
- createStore для создания хранилища Redux
- combineReducers для объединения нескольких reducers в один более крупный reducer
- applyMiddleware для объединения нескольких middleware в store enhancers
- сompose для объединения нескольких enhancers в один enhancers.
*/

// Помимо этого, вся остальная логика, связанная с Redux, в вашем приложении должна быть полностью написана вами.

// Хорошей новостью является то, что это означает, что Redux можно использовать по-разному. Плохая новость заключается в том, что нет помощников, которые могли бы облегчить написание вашего кода.

// Например, функция редуктора — это просто функция. До Redux Toolkit вы обычно писали этот reducer с оператором переключения и обновлениями вручную. У вас также, вероятно, будут рукописные создатели действий и константы типов действий:

//* Устаревшее
const ADD_TODO = 'ADD_TODO';
const TODO_TOGGLED = 'TODO_TOGGLED';

export const addTodo = text => ({
  type: ADD_TODO,
  payload: { text, id: nanoid() },
});

export const todoToggled2 = id => ({
  type: TODO_TOGGLED,
  payload: { id },
});

export const todosReducer = (state = [], action) => {
  switch (action.type) {
    case ADD_TODO:
      return state.concat({
        id: action.payload.id,
        text: action.payload.text,
        completed: false,
      });
    case TODO_TOGGLED:
      return state.map(todo => {
        if (todo.id !== action.payload.id) return todo;

        return {
          ...todo,
          completed: !todo.completed,
        };
      });
    default:
      return state;
  }
};

// Ни один из этих кодов конкретно не зависит от какого-либо API из redux основной библиотеки. Но нужно написать много кода. Неизменяемые обновления требовали большого количества рукописных расширений объектов и операций с массивами, и было очень легко допустить ошибки и случайно изменить состояние в процессе (всегда причина №1 ошибок Redux!). Также было обычным, хотя и не строго обязательным, распределять код одной функции по нескольким файлам, таким как actions/todos.js, constants/todos.jsи reducers/todos.js.

// Кроме того, настройка магазина обычно требовала ряда шагов для добавления часто используемого промежуточного программного обеспечения, такого как thunks, и включения поддержки расширения Redux DevTools Extension, хотя это стандартные инструменты, используемые почти в каждом приложении Redux.

//# Что делает Redux Toolkit?
// Хотя эти шаблоны изначально были показаны в документации Redux, они, к сожалению, требуют большого количества очень многословного и повторяющегося кода. Большая часть этого шаблона не обязательна для использования Redux. Вдобавок ко всему, шаблонный код приводит к большему количеству возможностей для ошибок.

// Мы специально создали Redux Toolkit, чтобы исключить «шаблон» из рукописной логики Redux, предотвратить типичные ошибки и предоставить API, которые упрощают стандартные задачи Redux.

/* Redux Toolkit начинается с двух ключевых API, которые упрощают наиболее распространенные действия в каждом приложении Redux:

- configureStore настраивает хорошо настроенное хранилище Redux с помощью одного вызова функции, включая объединение редукторов, добавление промежуточного программного обеспечения Thunk и настройку интеграции Redux DevTools. Его также проще настроить, чем createStore, поскольку он принимает именованные параметры.
- createSlice позволяет писать редукторы, которые используют библиотеку Immer для записи неизменяемых обновлений с использованием «мутирующего» синтаксиса JS, такого как state.value = 123, без необходимости расширения. Он также автоматически генерирует функции создания действий для каждого редуктора и внутренне генерирует строки типов действий на основе имен вашего редуктора. Наконец, он отлично работает с TypeScript.
*/

// Это означает, что код, который вы пишете, может быть значительно проще. Например, тот же самый редуктор todos может быть просто:

//* features/todos/todosSlice.js
import { createSlice } from '@reduxjs/toolkit';

const todosSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: {
    todoAdded(state, action) {
      state.push({
        id: action.payload.id,
        text: action.payload.text,
        completed: false,
      });
    },
    todoToggled(state, action) {
      const todo = state.find(todo => todo.id === action.payload);
      todo.completed = !todo.completed;
    },
  },
});

export const { todoAdded, todoToggled } = todosSlice.actions;
export default todosSlice.reducer;

// Все создатели action и action types генерируются автоматически, а код редуктора короче и легче для понимания. Также становится гораздо яснее, что на самом деле обновляется в каждом случае.

// С помощью configureStore настройку store можно упростить до:

//* app/store.js
import { configureStore } from '@reduxjs/toolkit';
import todosReducer from '../features/todos/todosSlice';
import filtersReducer from '../features/filters/filtersSlice';

export const store = configureStore({
  reducer: {
    todos: todosReducer,
    filters: filtersReducer,
  },
});

/* Обратите внимание, что этот вызов configureStore автоматически выполняет всю обычную работу по настройке, которую вы выполняли бы вручную:
- slice reducers были автоматически переданы в функцию combineReducers().
- Redux-thunk middleware было добавлено автоматически.
- Было добавлено middleware для режима разработки для обнаружения случайных мутаций.
- Расширение Redux DevTools было установлено автоматически.
- Усилители middleware и DevTools были составлены вместе и добавлены в store.
*/

// В то же время configureStore предоставляет пользователям возможность изменять любое из этих действий по умолчанию (например, отключение переходников и добавление sagas или отключение DevTools в рабочей среде).

/* Оттуда Redux Toolkit включает в себя другие API для распространенных задач Redux:
- createAsyncThunk: абстрагирует стандартный шаблон «действия по отправке до/после асинхронного запроса».
- createEntityAdapter: встроенные редукторы и селекторы для операций CRUD в нормализованном состоянии.
- createSelector: реэкспорт стандартного API Reselect для запоминаемых селекторов.
- createListenerMiddleware: промежуточное программное обеспечение с побочными эффектами для запуска логики в ответ на отправленные действия.
*/

// Наконец, пакет RTK также включает в себя «RTK Query», полное решение для извлечения и кэширования данных для приложений Redux, в качестве отдельной дополнительной @reduxjs/toolkit/queryточки входа. Он позволяет вам определять конечные точки (REST, GraphQL или любую асинхронную функцию) и генерирует редуктор и промежуточное программное обеспечение, которые полностью управляют получением данных, обновлением состояния загрузки и кэшированием результатов. Он также автоматически генерирует перехватчики React, которые можно использовать в компонентах для получения данных, напримерconst { data, isFetching} = useGetPokemonQuery('pikachu')

// Каждый из этих API является совершенно необязательным и предназначен для конкретных случаев использования, и вы можете выбирать, какие API вы действительно используете в своем приложении. Но всем им настоятельно рекомендуется помочь с этими задачами.

// Обратите внимание, что Redux Toolkit по-прежнему остается «Redux»! По-прежнему существует одно хранилище с отправляемыми объектами действий для обновлений и редукторами, которые неизменно обновляют состояние, а также возможностью писать преобразователи для асинхронной логики, управлять нормализованным состоянием, печатать код с помощью TypeScript и использовать DevTools. Для достижения тех же результатов вам придется написать гораздо меньше кода!
