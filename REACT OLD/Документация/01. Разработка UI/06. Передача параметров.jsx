//# Передача параметров
// Компоненты React используют props для взаимодействия друг с другом. Каждый родительский компонент может передавать некоторую информацию своим дочерним компонентам, передавая им параметры. Параметры могут напомнить вам атрибуты HTML, но через них можно передавать любые значения JavaScript, включая объекты, массивы и функции.

/* Вы узнаете
- Как передать параметры компоненту
- Как читать параметры из компонента
- Как указать значения по умолчанию для параметров
- Как передать некоторый JSX в компонент
- Как параметры изменяются со временем
*/

//# Известные параметры
// Параметры - это информация, которую вы передаете в тег JSX. Например, className, src, alt, width и height - вот некоторые из параметров, которые вы можете передать тегу <img>:

//* App.js
function Avatar() {
  return <img className="avatar" src="https://i.imgur.com/1bX5QH6.jpg" alt="Lin Lanying" width={100} height={100} />;
}

function Profile() {
  return <Avatar />;
}

// Параметры, которые вы можете передать тегу <img>, предопределены (ReactDOM соответствует стандарту HTML). Но вы можете передавать любые параметры своим компонентам, таким как <Avatar>, чтобы настроить их. Вот как!

//# Передача параметров компоненту
// В этом коде компонент Profile не передает никаких параметров своему дочернему компоненту Avatar:

function Profile() {
  return <Avatar />;
}

// Вы можете передать Avatar некоторые параметры в два этапа.

//* Шаг 1: Передайте параметры дочернему компоненту
// Сначала передайте Avatar некоторые параметры. Например, передадим два параметра: person (объект) и size (число):

function Profile() {
  return (
    <Avatar
      person={{
        name: 'Lin Lanying',
        imageId: '1bX5QH6',
      }}
      size={100}
    />
  );
}

//* Примечание
// Если двойные фигурные скобки после person= вас смущают, вспомните они просто объект внутри JSX-скобок.
//* Примечание

// Теперь вы можете прочитать эти параметры внутри компонента Avatar.

//* Шаг 2: Чтение параметров внутри дочернего компонента
// Вы можете прочитать эти параметры, перечислив их имена person, size, разделенные запятыми внутри ({ и }) непосредственно после функции Avatar. Это позволит вам использовать их внутри кода Avatar, как вы бы сделали это с переменной.

function Avatar({ person, size }) {
  // person and size are available here
}

// Добавьте в Avatar логику, которая использует параметры person и size для рендеринга, и все готово.

// Теперь вы можете настроить Avatar для рендеринга различными способами с различными параметрами. Попробуйте настроить значения!

//* utils.js
function getImageUrl(person, size = 's') {
  return 'https://i.imgur.com/' + person.imageId + size + '.jpg';
}

//* App.js
import { getImageUrl } from './utils.js';

function Avatar({ person, size }) {
  return <img className="avatar" src={getImageUrl(person)} alt={person.name} width={size} height={size} />;
}

function Profile() {
  return (
    <div>
      <Avatar
        size={100}
        person={{
          name: 'Katsuko Saruhashi',
          imageId: 'YfeOqp2',
        }}
      />
      <Avatar
        size={80}
        person={{
          name: 'Aklilu Lemma',
          imageId: 'OKS67lh',
        }}
      />
      <Avatar
        size={50}
        person={{
          name: 'Lin Lanying',
          imageId: '1bX5QH6',
        }}
      />
    </div>
  );
}

// Параметры позволяют вам думать о родительских и дочерних компонентах независимо друг от друга. Например, вы можете изменить параметры person или size внутри Profile без необходимости думать о том, как Avatar использует их. Аналогично, вы можете изменить то, как Avatar использует эти параметры, не заглядывая в Profile.

// Вы можете думать о параметрах как о "ручках", которые можно регулировать. Они выполняют ту же роль, что и аргументы для функций - фактически, параметр является единственным аргументом вашего компонента! Функции компонентов React принимают единственный аргумент - объект props:

function Avatar(props) {
  let person = props.person;
  let size = props.size;
  // ...
}

//! Внимание
// Не пропустите пару символов { и } внутри ( и ) при объявлении параметров:
function Avatar({ person, size }) {
  // ...
}

// Этот синтаксис называется "деструктуризация" и эквивалентен чтению свойств из параметра функции:
function Avatar(props) {
  let person = props.person;
  let size = props.size;
  // ...
}
//! Внимание

//# Указание значения по умолчанию для параметра
// Если вы хотите задать значение по умолчанию для параметра, когда значение не указано, вы можете сделать это с помощью деструктуризации, поместив = и значение по умолчанию сразу после параметра:

function Avatar({ person, size = 100 }) {
  // ...
}

// Теперь, если <Avatar person={...} /> отображается без свойства size, то size будет установлен в 100.

// Значение по умолчанию используется только в том случае, если параметр size отсутствует или если вы передали size={undefined}. Но если вы передадите size={null} или size={0}, значение по умолчанию не будет использоваться.

//# Пересылка параметров с синтаксисом JSX spread
// Иногда передача параметров становится очень повторяющейся:
function Profile({ person, size, isSepia, thickBorder }) {
  return (
    <div className="card">
      <Avatar person={person} size={size} isSepia={isSepia} thickBorder={thickBorder} />
    </div>
  );
}

// Нет ничего плохого в повторяющемся коде - он может быть более разборчивым. Но иногда вам может быть важна краткость. Некоторые компоненты передают все свои параметры своим дочерним компонентам, например, как этот Profile делает это с Avatar. Поскольку они не используют параметры напрямую, имеет смысл использовать более лаконичный синтаксис "spread":
function Profile(props) {
  return (
    <div className="card">
      <Avatar {...props} />
    </div>
  );
}

// Это пересылает все параметры Profile в Avatar без перечисления имен каждого из них.

// Используйте синтаксис распространения сдержанно. Если вы используете его в каждом втором компоненте, что-то не так. Часто это указывает на то, что вам следует разделить ваши компоненты и передавать дочерние компоненты как JSX. Подробнее об этом далее!

//# Передача JSX в качестве дочерних компонентов
// Часто встречается вложение встроенных тегов браузера:
<div>
  <img />
</div>;

// Иногда вы захотите вложить свои собственные компоненты таким же образом:
<Card>
  <Avatar />
</Card>;

// Когда вы вложите содержимое в JSX-тег, родительский компонент получит это содержимое в свойстве children. Например, компонент Card ниже получит параметр children, установленный в <Avatar />, и отобразит его в обертке div:

//* utils.js
function getImageUrl(person, size = 's') {
  return 'https://i.imgur.com/' + person.imageId + size + '.jpg';
}

//* Avatar.js
import { getImageUrl } from './utils.js';

function Avatar({ person, size }) {
  return <img className="avatar" src={getImageUrl(person)} alt={person.name} width={size} height={size} />;
}

//* App.js
import Avatar from './Avatar.js';

function Card({ children }) {
  return <div className="card">{children}</div>;
}

function Profile() {
  return (
    <Card>
      <Avatar
        size={100}
        person={{
          name: 'Katsuko Saruhashi',
          imageId: 'YfeOqp2',
        }}
      />
    </Card>
  );
}

// Попробуйте заменить <Avatar> внутри <Card> каким-нибудь текстом, чтобы увидеть, как компонент Card может обернуть любое вложенное содержимое. Ему не нужно "знать", что отображается внутри него. Вы увидите этот гибкий шаблон во многих местах.

// Вы можете думать о компоненте с параметром children как о компоненте с "дырой", которая может быть "заполнена" его родительскими компонентами с помощью произвольного JSX. Вы часто будете использовать параметр children для визуальных оберток: панелей, сеток и т. д.

//# Как параметры меняются со временем
// Компонент Clock ниже получает два параметра от своего родительского компонента: color и time. (Код родительского компонента опущен, поскольку он использует state, в который мы пока не будем углубляться).

// Попробуйте изменить цвет в поле выбора ниже:

//* Clock.js
function Clock({ color, time }) {
  return <h1 style={{ color: color }}>{time}</h1>;
}

//* App.js
import { useState, useEffect } from 'react';
import Clock from './Clock.js';

function useTime() {
  const [time, setTime] = useState(() => new Date());
  useEffect(() => {
    const id = setInterval(() => {
      setTime(new Date());
    }, 1000);
    return () => clearInterval(id);
  }, []);
  return time;
}

function App() {
  const time = useTime();
  const [color, setColor] = useState('lightcoral');
  return (
    <div>
      <p>
        Pick a color:{' '}
        <select value={color} onChange={e => setColor(e.target.value)}>
          <option value="lightcoral">lightcoral</option>
          <option value="midnightblue">midnightblue</option>
          <option value="rebeccapurple">rebeccapurple</option>
        </select>
      </p>
      <Clock color={color} time={time.toLocaleTimeString()} />
    </div>
  );
}

// Этот пример иллюстрирует, что компонент может получать различные параметры с течением времени. параметры не всегда статичны! Здесь параметр time меняется каждую секунду, а параметр color меняется, когда вы выбираете другой цвет. параметры отражают данные компонента в любой момент времени, а не только в начале.

// Однако параметры являются immutable - термин из информатики, означающий "неизменный". Когда компоненту нужно изменить свой параметр (например, в ответ на взаимодействие с пользователем или новые данные), он должен "попросить" свой родительский компонент передать ему другой параметр - новый объект! Его старые параметры будут отброшены, и в конечном итоге движок JavaScript вернет память, занятую ими.

// Не пытайтесь "менять параметры". Когда вам нужно отреагировать на ввод пользователя (например, изменить выбранный цвет), вам нужно будет "установить состояние", о котором вы можете узнать в State: A Component's Memory.

//# Итоги
/*
- Чтобы передать параметры, добавьте их в JSX, точно так же, как это делается с атрибутами HTML.
- Чтобы прочитать параметр, используйте синтаксис деструктуризации function Avatar({ person, size }).
- Вы можете указать значение по умолчанию, например size = 100, которое используется для отсутствующих и неопределенных параметров.
- Вы можете переслать все параметры с помощью <Avatar {...props} /> Синтаксис распространения JSX, но не злоупотребляйте им!
- Вложенные JSX типа <Card><Avatar /></Card> будут отображаться как дочерние параметры компонента Card.
- Параметры - это снимки времени, доступные только для чтения: каждый рендер получает новую версию параметра.
- Вы не можете изменять параметры. Когда вам понадобится интерактивность, вам нужно будет установить состояние.
*/
