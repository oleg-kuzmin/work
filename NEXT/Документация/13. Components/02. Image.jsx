//# <Image>
// Этот справочник по API поможет вам понять, как использовать реквизиты и параметры конфигурации, доступные для компонента изображения.

//* app/page.js (export default)
import Image from 'next/image';

function Page() {
  return <Image src="/profile.png" width={500} height={500} alt="Picture of the author" />;
}

//# Props
/* Вот краткий обзор реквизитов, доступных для компонента изображения:
Prop	            Example	                            Type	          Required
src	              src="/profile.png"	                String	        Yes
width	            width={500}	                        Integer (px)	  Yes
height	          height={500}	                      Integer (px)	  Yes
alt	              alt="Picture of the author"	        String	        Yes
loader	          loader={imageLoader}	              Function	      -
fill	            fill={true}	                        Boolean	        -
sizes	            sizes="(max-width: 768px) 100vw"	  String	        -
quality	          quality={80}	                      Integer (1-100)	-
priority	        priority={true}	                    Boolean	        -
placeholder	      placeholder="blur"	                String	        -
style	            style={{objectFit: "contain"}}	    Object	        -
onLoadingComplete	onLoadingComplete={img => done())}	Function	      -
onLoad	          onLoad={event => done())}	          Function	      -
onError	          onError(event => fail()}	          Function	      -
loading	          loading="lazy"	                    String	        -
blurDataURL	      blurDataURL="data:image/jpeg..."	  String	        -
*/

//# Обязательные props (добавить export default)
//* app/page.js (export default)
import Image from 'next/image';

function Page() {
  return (
    <div>
      <Image src="/profile.png" width={500} height={500} alt="Picture of the author" />
    </div>
  );
}

//# src (Обязательные props)
/* Должно быть одно из следующих:
- Статически импортированный файл изображения.
- Строка пути. Это может быть либо абсолютный внешний URL-адрес, либо внутренний путь в зависимости от свойства loader.
*/

// При использовании внешнего URL-адреса его необходимо добавить в remotePatterns в файле next.config.js.

//# width (Обязательные props)
// Свойство width представляет визуализированную ширину в пикселях, поэтому оно влияет на размер изображения.
// Обязательно, за исключением статически импортированных изображений или изображений со свойством fill.

//# height (Обязательные props)
// Свойство height представляет визуализированную высоту в пикселях, поэтому оно влияет на размер изображения.
// Обязательно, за исключением статически импортированных изображений или изображений со свойством fill.

//# alt (Обязательные props)
// Свойство alt используется для описания изображения для программ чтения с экрана и поисковых систем. Это также резервный текст, если изображения отключены или при загрузке изображения возникает ошибка.

// Он должен содержать текст, который мог бы заменить изображение, не меняя смысла страницы. Оно не предназначено для дополнения изображения и не должно повторять информацию, уже представленную в подписях над или под изображением.

// Если изображение носит чисто декоративный характер или не предназначено для пользователя, свойство alt должно быть пустой строкой (alt="").

//# Опциональные props
// Компонент <Image /> принимает ряд дополнительных свойств помимо обязательных. В этом разделе описаны наиболее часто используемые свойства компонента Image.

//# loader (Опциональные props)
// Пользовательская функция, используемая для разрешения URL-адресов изображений.

/* loader — это функция, возвращающая строку URL-адреса изображения при следующих параметрах:
- src
- width
- quality
*/

// Вот пример использования пользовательского loader:

//* app/page.js (export default)
('use client');

import Image from 'next/image';

const imageLoader = ({ src, width, quality }) => {
  return `https://example.com/${src}?w=${width}&q=${quality || 75}`;
};

function Page() {
  return <Image loader={imageLoader} src="me.png" alt="Picture of the author" width={500} height={500} />;
}

// Полезно знать: использование таких props, как loader, которые принимают функцию, требует использования клиентских компонентов для реализации предоставленной функции.

// Альтернативно вы можете использовать конфигурацию loaderFile в next.config.js для настройки каждого экземпляра next/image в вашем приложении без передачи реквизита.

//# fill (Опциональные props)
// fill={true} // {true} | {false}

// Логическое значение, которое заставляет изображение заполнять родительский элемент, что полезно, когда ширина и высота неизвестны.

// Родительскому элементу необходимо присвоить position: "relative", position: "fixed" или position: "absolute".

// По умолчанию элементу img автоматически будет присвоен position: "absolute".

// Если к изображению не применены стили, оно растянется по размеру контейнера. Вы можете предпочесть установить object-fit: "contain" для изображения, которое имеет почтовый ящик, чтобы соответствовать контейнеру и сохранять соотношение сторон.

// Альтернативно, object-fit: «cover» приведет к тому, что изображение заполнит весь контейнер и будет обрезано, чтобы сохранить соотношение сторон. Чтобы это выглядело правильно, родительскому элементу должен быть присвоен стиль overflow: "hidden".

//# sizes (Опциональные props)
// Строка, похожая на медиа-запрос, которая предоставляет информацию о том, насколько шириной будет изображение в различных точках останова. Значение размеров будет сильно влиять на производительность изображений, использующих fill или стилизованных под адаптивный размер.

/* Свойство размеров служит двум важным целям, связанным с производительностью изображения:

- Во-первых, значение sizes используется браузером для определения размера изображения для загрузки из автоматически сгенерированного набора srcset next/image. Когда браузер делает выбор, он еще не знает размер изображения на странице, поэтому он выбирает изображение того же размера или больше, чем область просмотра. Свойство sizes позволяет сообщить браузеру, что изображение на самом деле будет меньше полноэкранного. Если вы не укажете значение sizes в изображении со свойством fill будет использовано дефолтное значение 100vw (полная ширина экрана).

- Во-вторых, свойство sizes изменяет поведение автоматически сгенерированного значения srcset. Если значение sizes отсутствует, генерируется небольшой srcset, подходящий для изображений фиксированного размера (1x/2x/etc). Если sizes определен - генерируется большой srcset, подходящий для адаптивного изображения (640w/750w/etc). Если свойство sizes включает такие размеры, как 50vw, которые представляют собой процент ширины области просмотра, то набор srcset обрезается, чтобы не включать в себя какие-либо значения, которые слишком малы.
*/

// Например, если вы знаете, что ваш стиль приведет к тому, что изображение будет иметь полную ширину на мобильных устройствах, макет в 2 столбца на планшетах и ​​макет в 3 столбца на настольных компьютерах, вам следует включить свойство размеров, например следующее:

import Image from 'next/image';

function Page() {
  return (
    <div className="grid-element">
      <Image fill src="/example.png" sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw" />
    </div>
  );
}

// Sizes в этом примере могут оказать существенное влияние на показатели производительности. Без размеров 33vw изображение, выбранное с сервера, было бы в 3 раза шире, чем необходимо. Поскольку размер файла пропорционален квадрату ширины, без размеров пользователь загрузит изображение, которое в 9 раз больше необходимого.

//# quality (Опциональные props)
// quality={75} // {number 1-100}
// Качество оптимизированного изображения, целое число от 1 до 100, где 100 – наилучшее качество и, следовательно, наибольший размер файла. По умолчанию 75.

//# priority (Опциональные props)
// priority={false} // {false} | {true}

// Если установлено значение true, изображение будет иметь высокий приоритет и будет предварительно загружено. Отложенная загрузка автоматически отключается для изображений, использующих приоритет.

// Свойство Priority следует использовать для любого изображения, обнаруженного как элемент Largest Contentful Paint (LCP). Возможно, будет целесообразно иметь несколько приоритетных изображений, поскольку разные изображения могут быть элементом LCP для разных размеров области просмотра.

// Следует использовать только в том случае, если изображение видно над сгибом. По умолчанию false.

//# placeholder (Опциональные props)
// placeholder = 'empty' // "empty" | "blur" | "data:image/..."

// Placeholder, который будет использоваться во время загрузки изображения. Возможные значения: размытие, пусто или data:image/.... По умолчанию пусто.

// При размытии в качестве placeholder будет использоваться свойство blurDataURL. Если src является объектом статического импорта, а импортированное изображение имеет формат .jpg, .png, .webp или .avif, то blurDataURL будет автоматически заполнен, за исключением случаев, когда изображение определяется как анимированное.

// Для динамических изображений необходимо указать свойство blurDataURL. Такие решения, как placeholder, могут помочь с генерацией base64.

// Если data:image/..., URL-адрес данных будет использоваться в качестве placeholder во время загрузки изображения.

// Если оно пустое, во время загрузки изображения не будет placeholder, а будет только пустое пространство.

//# Расширенные props
// В некоторых случаях вам может потребоваться более расширенное использование. Компонент <Image /> дополнительно принимает следующие дополнительные свойства.

//# style (Расширенные props)
// Позволяет передавать стили CSS базовому элементу изображения.

//* components/ProfileImage.js (export default)
const imageStyle = {
  borderRadius: '50%',
  border: '1px solid #fff',
};

function ProfileImage() {
  return <Image src="..." style={imageStyle} />;
}

// Помните, что требуемая ширина и высота могут взаимодействовать с вашим стилем. Если вы используете стиль для изменения ширины изображения, вам также следует задать для его высоты значение auto, чтобы сохранить его внутреннее соотношение сторон, иначе ваше изображение будет искажено.

//# onLoadingComplete (Расширенные props)
('use client');
<Image onLoadingComplete={img => console.log(img.naturalWidth)} />;

// Функция обратного вызова, которая вызывается после полной загрузки изображения и удаления placeholder.

// Функция обратного вызова будет вызвана с одним аргументом — ссылкой на базовый элемент <img>.

// Полезно знать: использование таких реквизитов, как onLoadingComplete, которые принимают функцию, требует использования клиентских компонентов для реализации предоставленной функции.

//# onLoad (Расширенные props)
('use client');
<Image onLoad={e => console.log(e.target.naturalWidth)} />;

// Функция обратного вызова, которая вызывается при загрузке изображения.

// Событие загрузки может произойти до того, как placeholder изображения будет удален и изображение будет полностью декодировано. Если вы хотите дождаться полной загрузки изображения, используйте вместо этого onLoadingComplete.

// Полезно знать: использование таких реквизитов, как onLoad, которые принимают функцию, требует использования клиентских компонентов для реализации предоставленной функции.

//# onError (Расширенные props)
('use client');
<Image onError={e => console.error(e.target.id)} />;

// Функция обратного вызова, которая вызывается, если изображение не загружается.

// Полезно знать: использование таких реквизитов, как onError, которые принимают функцию, требует использования клиентских компонентов для сериализации предоставленной функции.

//# loading (Расширенные props)
// loading = 'lazy' // {lazy} | {eager}

// Рекомендация: это свойство предназначено только для расширенных случаев использования. Переключение изображения на загрузку с помощью eager обычно снижает производительность. Вместо этого мы рекомендуем использовать свойство Priority, которое будет предварительно загружать изображение.

// Поведение загрузки изображения. По умолчанию ленивый

// Если lazy, отложите загрузку изображения до тех пор, пока оно не достигнет расчетного расстояния от области просмотра.

// Если eager, немедленно загрузите изображение.

//# blurDataURL (Расширенные props)
// URL-адрес данных, который будет использоваться в качестве изображения-placeholder перед успешной загрузкой исходного изображения. Действует только в сочетании с placeholder="blur".

// Должно быть изображение в кодировке Base64. Оно будет увеличено и размыто, поэтому рекомендуется использовать очень маленькое изображение (10 пикселей или меньше). Использование изображений большего размера в качестве placeholder может снизить производительность вашего приложения.

//# unoptimized (Расширенные props)
// unoptimized = {false} // {false} | {true}

// Если установлено значение true, исходное изображение будет отображаться как есть, без изменения качества, размера или формата. По умолчанию false.

import Image from 'next/image';

const UnoptimizedImage = props => {
  return <Image {...props} unoptimized />;
};

// Начиная с Next.js 12.3.0, это свойство можно назначить всем изображениям, обновив next.config.js следующей конфигурацией:

//* next.config.js
module.exports = {
  images: {
    unoptimized: true,
  },
};

//# Другие props
/* Другие свойства компонента <Image /> будут переданы базовому элементу img, за исключением следующих:
- srcSet. Вместо этого используйте размеры устройств.
- decoding. Это всегда async.
*/

//# Параметры конфигурации
// Помимо props, вы можете настроить компонент изображения в next.config.js. Доступны следующие варианты:

//# remotePatterns (Параметры конфигурации)
// Чтобы защитить ваше приложение от злоумышленников, необходимо настроить использование внешних образов. Это гарантирует, что API оптимизации изображений Next.js может обслуживать только внешние изображения из вашей учетной записи. Эти внешние изображения можно настроить с помощью свойства RemotePatterns в файле next.config.js, как показано ниже:

//* next.config.js
module.exports = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'example.com',
        port: '',
        pathname: '/account123/**',
      },
    ],
  },
};

// Полезно знать: в приведенном выше примере свойство src объекта next/image должно начинаться с https://example.com/account123/. Любой другой протокол, имя хоста, порт или несовпадающий путь ответит 400 Bad Request.

// Ниже приведен еще один пример свойства remotePatterns в файле next.config.js:

//* next.config.js
module.exports = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: '**.example.com',
      },
    ],
  },
};

// Полезно знать: приведенный выше пример гарантирует, что src свойство next/image должно начинаться с https://img1.example.com любого https://me.avatar.example.com количества поддоменов. Любой другой протокол или несовпадающее имя хоста ответит 400 Bad Request.

/* Шаблоны подстановочных знаков могут использоваться как для пути, так и для имени хоста и имеют следующий синтаксис:
- * соответствовать одному сегменту пути или поддомену
- ** соответствовать любому количеству сегментов пути в конце или поддоменов в начале
*/

// Синтаксис ** не работает в середине шаблона.

//# domains (Параметры конфигурации)
// Предупреждение. Мы рекомендуем настроить remotePatterns вместо доменов, чтобы защитить ваше приложение от злоумышленников. Используйте домены только в том случае, если вы владеете всем контентом, предоставляемым из домена.

// Как и в случае с remotePatterns, конфигурацию доменов можно использовать для предоставления списка разрешенных имен хостов для внешних образов.

// Однако конфигурация доменов не поддерживает сопоставление с шаблоном подстановочных знаков и не может ограничивать протокол, порт или путь.

// Ниже приведен пример свойства доменов в файле next.config.js:

//* next.config.js
module.exports = {
  images: {
    domains: ['assets.acme.com'],
  },
};

//# loaderFile (Параметры конфигурации)
// Если вы хотите использовать облачный провайдер для оптимизации изображений вместо использования встроенного API оптимизации изображений Next.js, вы можете настроить файл loaderFile в файле next.config.js следующим образом:

//* next.config.js
module.exports = {
  images: {
    loader: 'custom',
    loaderFile: './my/image/loader.js',
  },
};

// Это должно указывать на файл относительно корня вашего приложения Next.js. Файл должен экспортировать функцию по умолчанию, которая возвращает строку, например:
//* ./my/image/loader.js (export default)
('use client');

function myImageLoader({ src, width, quality }) {
  return `https://example.com/${src}?w=${width}&q=${quality || 75}`;
}

// Альтернативно вы можете использовать свойство loader для настройки каждого экземпляра next/image.

//# Расширенные параметры конфигурации
// Следующая конфигурация предназначена для расширенных случаев использования и обычно не требуется. Если вы решите настроить свойства ниже, вы переопределите любые изменения в настройках Next.js по умолчанию в будущих обновлениях.

//# deviceSizes (Расширенные параметры конфигурации)
// Если вы знаете ожидаемую ширину устройств ваших пользователей, вы можете указать список контрольных точек ширины устройства, используя свойство deviceSizes в файле next.config.js. Эти ширины используются, когда компонент next/image использует свойство размеров, чтобы обеспечить правильное изображение для устройства пользователя.

// Если конфигурация не указана, используется значение по умолчанию, указанное ниже.

//* next.config.js
module.exports = {
  images: {
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
  },
};

//# imageSizes (Расширенные параметры конфигурации)
// Вы можете указать список ширины изображения, используя свойство images.imageSizes в файле next.config.js. Эти ширины объединяются с массивом размеров устройства, чтобы сформировать полный массив размеров, используемый для создания наборов источников изображений.

// Причина создания двух отдельных списков заключается в том, что imageSizes используется только для изображений, которые предоставляют свойство размеров, указывающее, что изображение меньше полной ширины экрана. Таким образом, все размеры в imageSizes должны быть меньше наименьшего размера в deviceSizes.

// Если конфигурация не указана, используется значение по умолчанию, указанное ниже.

//* next.config.js
module.exports = {
  images: {
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
  },
};

//# formats (Расширенные параметры конфигурации)
// API оптимизации изображений по умолчанию автоматически определяет поддерживаемые браузером форматы изображений через заголовок Accept запроса.

// Если заголовок Accept соответствует более чем одному из настроенных форматов, используется первое совпадение в массиве. Поэтому порядок массива имеет значение. Если совпадений нет (или исходное изображение анимировано), API оптимизации изображений вернется к формату исходного изображения.

// Если конфигурация не указана, используется значение по умолчанию, указанное ниже.

//* next.config.js
module.exports = {
  images: {
    formats: ['image/webp'],
  },
};

// Вы можете включить поддержку AVIF с помощью следующей конфигурации.

//* next.config.js
module.exports = {
  images: {
    formats: ['image/avif', 'image/webp'],
  },
};

/* Хорошо знать:
- Кодирование AVIF обычно занимает на 20% больше времени, но сжимает на 20% меньше, чем WebP. Это означает, что при первом запросе изображения оно обычно будет медленнее, а последующие кэшированные запросы будут быстрее.
- Если вы самостоятельно размещаете прокси/CDN перед Next.js, вам необходимо настроить прокси для пересылки заголовка Accept.
*/

//# Поведение кэширования
// Ниже описан алгоритм кэширования для загрузчика по умолчанию. Для всех остальных загрузчиков обратитесь к документации вашего облачного провайдера.

// Изображения оптимизируются динамически по запросу и сохраняются в каталоге <distDir>/cache/images. Оптимизированный файл изображения будет использоваться для последующих запросов до истечения срока его действия. Когда делается запрос, который соответствует кэшированному файлу с истекшим сроком действия, изображение с истекшим сроком действия немедленно обслуживается как устаревшее. Затем изображение снова оптимизируется в фоновом режиме (также называемое повторной проверкой) и сохраняется в кеше с новой датой истечения срока действия.

/* Статус кэша изображения можно определить, прочитав значение заголовка ответа x-nextjs-cache. Возможные значения следующие:
- MISS - пути нет в кеше (происходит максимум один раз, при первом посещении)
- STALE - путь находится в кеше, но время повторной проверки превысило время, поэтому он будет обновлен в фоновом режиме.
- HIT - путь находится в кеше и не превысил время повторной проверки
*/

// Срок действия (или, скорее, максимальный срок) определяется либо конфигурацией минимального CacheTTL, либо заголовком Cache-Control исходного образа, в зависимости от того, что больше. В частности, используется значение max-age заголовка Cache-Control. Если найдены и s-maxage, и max-age, то предпочтительнее s-maxage. Максимальный возраст также передается всем последующим клиентам, включая CDN и браузеры.

/*
- Вы можете настроить минимумCacheTTL для увеличения продолжительности кэширования, если восходящий образ не включает заголовок Cache-Control или его значение очень низкое.
- Вы можете настроить параметры deviceSizes и imageSizes, чтобы уменьшить общее количество возможных создаваемых изображений.
- Вы можете настроить форматы, чтобы отключить несколько форматов в пользу одного формата изображения.
*/

//# minimumCacheTTL (Поведение кэширования)
// Вы можете настроить время жизни (TTL) в секундах для кэшированных оптимизированных изображений. Во многих случаях лучше использовать импорт статического изображения, который автоматически хэширует содержимое файла и навсегда кэширует изображение с Cache-Control заголовком immutable.

//* next.config.js
module.exports = {
  images: {
    minimumCacheTTL: 60,
  },
};

// Срок действия (или, скорее, максимальный возраст) оптимизированного изображения определяется либо заголовком minimumCacheTTL исходного изображения, либо заголовком исходного изображения Cache-Control, в зависимости от того, что больше.

// Если вам нужно изменить поведение кэширования для каждого изображения, вы можете настроить headers установку Cache-Control заголовка в восходящем изображении (например /some-asset.jpg, не в /_next/imageнем самом).

// В настоящее время не существует механизма, позволяющего сделать кэш недействительным, поэтому лучше держать его minimumCacheTTL на низком уровне. В противном случае вам может потребоваться вручную изменить src реквизит или удалить его <distDir>/cache/images.

//# disableStaticImages (Поведение кэширования)
// Поведение по умолчанию позволяет импортировать статические файлы, например, import icon from './icon.png и затем передавать их свойству src.

// В некоторых случаях вы можете отключить эту функцию, если она конфликтует с другими плагинами, которые ожидают, что импорт будет вести себя по-другому.

// Вы можете отключить импорт статических изображений внутри вашего next.config.js:

//* next.config.js
module.exports = {
  images: {
    disableStaticImages: true,
  },
};

//# dangerouslyAllowSVG (Поведение кэширования)
// Загрузчик по умолчанию не оптимизирует изображения SVG по нескольким причинам. Во-первых, SVG — это векторный формат, что означает, что его размер можно изменять без потерь. Во-вторых, SVG имеет многие из тех же функций, что и HTML/CSS, что может привести к уязвимостям без надлежащей политики безопасности контента.

// Если вам нужно обслуживать изображения SVG с помощью API оптимизации изображений по умолчанию, вы можете установить dangerouslyAllowSVG в своем файле next.config.js:

//* next.config.js
module.exports = {
  images: {
    dangerouslyAllowSVG: true,
    contentDispositionType: 'attachment',
    contentSecurityPolicy: "default-src 'self'; script-src 'none'; sandbox;",
  },
};

// Кроме того, настоятельно рекомендуется также настроить contentDispositionType принудительное скачивание изображения браузером, а также contentSecurityPolicy запретить выполнение встроенных в изображение скриптов.

//# Анимированные изображения
// Загрузчик по умолчанию автоматически обходит оптимизацию изображений для анимированных изображений и отображает изображение как есть.

// Автоматическое обнаружение анимированных файлов является максимально эффективным и поддерживает GIF, APNG и WebP. Если вы хотите явно обойти оптимизацию изображения для данного анимированного изображения, используйте unoptimized.

//# Адаптивные изображения
// Сгенерированный по умолчанию набор srcset содержит изображения размером 1x и 2x для поддержки различных соотношений пикселей устройства. Однако вы можете захотеть визуализировать адаптивное изображение, которое растягивается вместе с областью просмотра. В этом случае вам нужно будет установить sizes, а также style (или имя className).

// Вы можете визуализировать адаптивное изображение, используя один из следующих методов, описанных ниже.

//# Адаптивное изображение с использованием статического импорта
// Если исходное изображение не является динамическим, вы можете статически импортировать его, чтобы создать адаптивное изображение:

//* components/author.js (export default)
import Image from 'next/image';
import me from '../photos/me.jpg';

function Author() {
  return (
    <Image
      src={me}
      alt="Picture of the author"
      sizes="100vw"
      style={{
        width: '100%',
        height: 'auto',
      }}
    />
  );
}

//# Адаптивное изображение с соотношением сторон
// Если исходное изображение является динамическим или удаленным URL-адресом, вам также потребуется указать ширину и высоту, чтобы установить правильное соотношение сторон адаптивного изображения:

//* components/page.js (export default)

import Image from 'next/image';

export default function Page({ photoUrl }) {
  return (
    <Image
      src={photoUrl}
      alt="Picture of the author"
      sizes="100vw"
      style={{
        width: '100%',
        height: 'auto',
      }}
      width={500}
      height={300}
    />
  );
}

//# Адаптивное изображение с fill
// Если вы не знаете соотношение сторон, вам нужно будет установить свойство fill и задать position: relative у родителя. При желании вы можете установить стиль object-fit в зависимости от желаемого поведения растягивания и обрезки:

//* app/page.js (export default)
import Image from 'next/image';

function Page({ photoUrl }) {
  return (
    <div style={{ position: 'relative', width: '500px', height: '300px' }}>
      <Image
        src={photoUrl}
        alt="Picture of the author"
        sizes="500px"
        fill
        style={{
          objectFit: 'contain',
        }}
      />
    </div>
  );
}

//# Обнаружение темы
// Если вы хотите отображать разные изображения для светлого и темного режима, вы можете создать новый компонент, который обертывает два компонента <Image> и показывает правильный на основе медиа-запроса CSS.

/*
components/theme-image.module.css
.imgDark {
  display: none;
}

@media (prefers-color-scheme: dark) {
  .imgLight {
    display: none;
  }
  .imgDark {
    display: unset;
  }
}
*/

//* components/theme-image.js
import styles from './theme-image.module.css';
import Image from 'next/image';

const ThemeImage = props => {
  const { srcLight, srcDark, ...rest } = props;

  return (
    <>
      <Image {...rest} src={srcLight} className={styles.imgLight} />
      <Image {...rest} src={srcDark} className={styles.imgDark} />
    </>
  );
};

// Полезно знать: поведение loading="lazy" по умолчанию гарантирует загрузку только правильного изображения. Вы не можете использовать priority или loading="eager", потому что это приведет к загрузке обоих изображений. Вместо этого вы можете использовать fetchPriority="high".

//# Известные ошибки браузера
// Этот компонент next/image использует встроенную отложенную загрузку браузера, которая может вернуться к быстрой загрузке для старых браузеров до Safari 15.4. При использовании placeholder размытия старые браузеры до Safari 12 будут использовать пустой placeholder. При использовании стилей с шириной/высотой auto можно вызвать сдвиг макета в старых браузерах до Safari 15, которые не сохраняют соотношение сторон. Более подробную информацию смотрите в этом видео (https://www.youtube.com/watch?v=4-d_SoCHeWE).

/* Safari 15–16.3 отображает серую рамку при загрузке. Safari 16.4 исправил эту проблему. Возможные решения:
- Use CSS @supports (font: -apple-system-body) and (-webkit-appearance: none) { img[loading="lazy"] { clip-path: inset(0.6px) } }
- Use priority если изображение находится выше сгиба.
*/

/* Firefox 67+ отображает белый фон при загрузке. Возможные решения:
- Включить форматы AVIF
- Использовать placeholder
*/
