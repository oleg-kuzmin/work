//# Аутентификация
/* Чтобы реализовать аутентификацию в Next.js, ознакомьтесь с тремя основополагающими понятиями:
- Аутентификация: проверяет, является ли пользователь тем, кем он себя называет. Он требует от пользователя подтвердить свою личность чем-то, что у него есть, например, именем пользователя и паролем.
- Управление сеансами: отслеживает состояние пользователя (например, вход в систему) по множеству запросов.
- Авторизация: определяет, к каким частям приложения пользователю разрешен доступ.
*/

// На этой странице показано, как использовать функции Next.js для реализации общих шаблонов аутентификации, авторизации и управления сеансами, чтобы вы могли выбирать лучшие решения в соответствии с потребностями вашего приложения.

//# Аутентификация
// Аутентификация подтверждает личность пользователя. Это происходит, когда пользователь входит в систему либо с именем пользователя и паролем, либо через такую ​​службу, как Google. Все дело в подтверждении того, что пользователи действительно являются теми, кем они себя называют, а также в защите как данных пользователя, так и приложения от несанкционированного доступа или мошеннических действий.

//# Стратегии аутентификации
// Современные веб-приложения обычно используют несколько стратегий аутентификации:

//* 1. OAuth/OpenID Connect (OIDC)
// включите доступ третьих лиц без предоставления учетных данных пользователя. Идеально подходит для входа в социальные сети и решений единого входа (SSO). Они добавляют уровень идентификации с помощью OpenID Connect.

//* 2. Вход на основе учетных данных (электронная почта + пароль)
// стандартный выбор для веб-приложений, где пользователи входят в систему, используя адрес электронной почты и пароль. Знакомый и простой в реализации, он требует надежных мер безопасности против таких угроз, как фишинг.

//* 3. Аутентификация без пароля/токена
// используйте магические ссылки по электронной почте или одноразовые коды SMS для безопасного доступа без пароля. Популярный благодаря своему удобству и повышенной безопасности, этот метод помогает снизить утомляемость паролем. Его ограничением является зависимость от доступности электронной почты или телефона пользователя.

//* 4. Passkeys/WebAuthn
// используйте криптографические учетные данные, уникальные для каждого сайта, обеспечивая высокий уровень защиты от фишинга. Эту безопасную, но новую стратегию может быть трудно реализовать.

// Выбор стратегии аутентификации должен соответствовать конкретным требованиям вашего приложения, соображениям пользовательского интерфейса и целям безопасности.

//# Реализация аутентификации
// В этом разделе мы рассмотрим процесс добавления базовой аутентификации по электронной почте и паролю в веб-приложение. Хотя этот метод обеспечивает фундаментальный уровень безопасности, стоит рассмотреть более продвинутые варианты, такие как OAuth или вход без пароля, для усиленной защиты от распространенных угроз безопасности. Процесс аутентификации, который мы обсудим, выглядит следующим образом:

/*
1. Пользователь отправляет свои учетные данные через форму входа.
2. Форма вызывает действие сервера.
3. При успешной проверке процесс завершается, что свидетельствует об успешной аутентификации пользователя.
4. Если проверка не удалась, отображается сообщение об ошибке.
*/

//* app/login/page.jsx
import { authenticate } from '@/app/lib/actions';

export default function Page() {
  return (
    <form action={authenticate}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Password" required />
      <button type="submit">Login</button>
    </form>
  );
}

// В приведенной выше форме есть два поля ввода для ввода адреса электронной почты и пароля пользователя. При отправке форма вызывает action={authenticate}.

// Затем вы можете вызвать API вашего поставщика аутентификации в действии сервера для обработки аутентификации:

//* app/lib/actions.js
('use server');

import { signIn } from '@/auth';

export async function authenticate(formData) {
  try {
    await signIn('credentials', formData);
  } catch (error) {
    if (error) {
      switch (error.type) {
        case 'CredentialsSignin':
          return 'Invalid credentials.';
        default:
          return 'Something went wrong.';
      }
    }
    throw error;
  }
}
