//# Promise (Запрос на асинхронный код)
/*
- Промис (Promise) — специальный объект JavaScript, который используется для написания и обработки асинхронного кода.
- Асинхронные функции возвращают объект Promise в качестве значения. Внутри промиса хранится результат вычисления, которое может быть уже выполнено или выполнится в будущем.
- Интересная и удобная особенность промисов – если вложить один промис в другой они схлопнутся в один.
- Код функции, переданной функции Promise, исполняется немедленно.
- Как только вы откроете файл, движок запустит код промиса: создаст переменную rand, присвоит ей true или false.

- Промис может находиться в одном из трёх состояний:
1) pending — стартовое состояние, операция стартовала
2) fulfilled — получен результат
3) rejected — ошибка

- Поменять состояние можно только один раз: перейти из pending либо в fulfilled, либо в rejected.
- У промиса есть методы then() и catch(), которые позволяют использовать результат вычисления внутри промиса.

- Промис решает задачу выполнения кода, который зависит от результата асинхронной операции.
- Промис устроен таким образом, что рычаги управления его состоянием остаются у асинхронной функции. После создания, промис находится в состоянии ожидания pending. Когда асинхронная операция завершается, функция переводит промис в состояние успеха fulfilled или ошибки rejected.
- С помощью методов then(), catch() и finally() мы можем реагировать на изменение состояния промиса и использовать результат его выполнения.
*/

//# создание (new Promise)
/*
- Промис создаётся с помощью конструктора.
- В конструктор передаётся функция-исполнитель асинхронной операции (англ. executor). Она вызывается сразу после создания промиса. Задача этой функции — выполнить асинхронную операцию и перевести состояние промиса в fulfilled (успех) или rejected (ошибка).
- Изменить состояние промиса можно, вызвав колбэки, переданные аргументами в функцию.
*/

// первый параметр (в примере кода назван resolve) — колбэк для перевода промиса в состояние fulfilled, при его вызове аргументом передаётся результат операции
const promise = new Promise(function (resolve, reject) {
  const data = getData(); // делаем асинхронную операцию: запрос в БД, API, etc.
  resolve(data); // переводим промис в состояние fulfilled. Результатом выполнения будет объект data
});

// второй параметр (в примере кода назван reject) — колбэк для перевода промиса в состояние rejected, при его вызове аргументом передаётся информация об ошибке
const errorPromise = new Promise(function (resolve, reject) {
  reject(new Error('ошибка')); // переводим промис в состояние rejected. Результатом выполнения будет объект Error
});

//# метод .then()
/*
- Метод then() используют, чтобы выполнить код после успешного выполнения асинхронной операции.

- Например, мы запросили у сервера список фильмов и хотим отобразить их на экране, когда сервер получит результат. В этом случае:
1) асинхронная операция — запрос данных у сервера;
2) код, который мы хотим выполнить после её завершения, — отрисовка списка.

- Метод then() принимает в качестве аргумента две функции-колбэка. Если промис в состоянии fulfilled то выполнится первая функция. Если в состоянии rejected — вторая. Хорошей практикой считается не использовать второй аргумент метода then() и обрабатывать ошибки при помощи метода catch().
*/

// В коде асинхронная функция fetch() возвращает промис, к которому применяется метод then. При его выполнении в переменной movies будет ответ сервера.
fetch(`https://swapi.dev/api/films/${id}/`).then(function (movies) {
  renderList(movies);
});

//# метод .catch()
/*
- Метод catch() используют, чтобы выполнить код в случае ошибки при выполнении асинхронной операции.
- Если в цепочке несколько catch(), то каждый ловит ошибки от then(), находящихся выше.

- Например, мы запросили у сервера список фильмов и хотим показать экран обрыва соединения, если произошла ошибка. В этом случае:
1) асинхронная операция — запрос данных у сервера;
2) код, который мы хотим выполнить при ошибке — экран обрыва соединения.

- Метод catch() принимает в качестве аргумента функцию-колбэк, которая выполняется сразу после того, как промис поменял состояние на rejected. Параметр колбэка содержит экземпляр ошибки.
*/

// В коде асинхронная функция fetch() возвращает промис, к которому применяется метод catch(). При его выполнении в переменной error будет экземпляр ошибки.
fetch(`https://swapi.dev/api/films/${id}/`).catch(function (error) {
  renderErrorMessage(error);
});

//# метод .finally()
/*
- Метод finally() используют, чтобы выполнить код при завершении асинхронной операции. Он будет выполнен вне зависимости от того, была ли операция успешной или завершилась ошибкой.

- Самый частый сценарий использования finally() — работа с индикаторами загрузки. Перед началом асинхронной операции разработчик включает индикатор загрузки. Индикатор нужно убрать вне зависимости от того, как завершилась операция. Если этого не сделать, то пользователь не сможет взаимодействовать с интерфейсом.

- Метод finally() принимает в качестве аргумента функцию-колбэк, которая выполняется сразу после того, как промис поменял состояние на rejected или fulfilled.
*/

let loading = true;
fetch(`https://swapi.dev/api/films/${id}/`).finally(function () {
  loading = false;
});

//# Цепочки методов
/*
- В этом случае при успешном завершении операции мы выполним код из then(), при ошибке — код из catch(). Затем выполнится код из finally().
- Цепочки методов — очень гибкий подход. Он позволяет создавать зависимые асинхронные операции.
- Например, нужно отобразить информацию о фильме и главном герое. Мы не знаем, кто главный герой, не получив эту информацию из данных о фильме. Таким образом, запрос данных о герое зависит от результата запроса данных о фильме.
*/

// Методы then(), catch() и finally() часто объединяют в цепочки вызовов, чтобы обработать и успешный, и ошибочный сценарии.
let isLoading = true;
fetch(`https://swapi.dev/api/films/${id}/`)
  .then(function (movies) {
    renderList(movies);
  })
  .catch(function (err) {
    renderErrorMessage(err);
  })
  .finally(function () {
    isLoading = false;
  });

// Промисы делают решение простым и читаемым. Мы можем начинать следующее асинхронное действие внутри колбэка метода then(). Все, что возвращается из колбэка, оборачивается в промис, поэтому в цепочку можно добавить новый then():
fetch(`https://swapi.dev/api/films/${id}/`)
  // этот then сработает, когда разрешится промис с запросом данных о фильме
  .then(function (response) {
    return response.json(); // нужно распарсить ответ сервера, это асинхронная операция
  })
  // этот then сработает, когда данные о фильме распарсятся
  .then(function (movie) {
    const characterUrl = movie.characters[0];
    return fetch(characterUrl); // вызов fetch вернет промис, возвращаем его из колбэка, чтобы продолжить цепочку
  })
  // этот then сработает, когда разрешится промис с результатами запроса персонажа
  .then(function (response) {
    return response.json();
  })
  .then(function (character) {
    renderCharacterProfile(character);
  })
  // catch сработает, когда любая из операций выше завершится ошибкой
  .catch(function (err) {
    renderErrorMessage(err);
  });

//# Promise.resolve()
// Если вы сразу хотите создать исполненный или отклонённый промис, вызывать new Promise необязательно. Можно обратиться к методам Promise.resolve и Promise.reject. Эти методы создают промис, переводят его в статус «исполнен» или «отклонён» соответственно, и записывают как результат промиса — то, что мы передали этим методам.
Promise.resolve('Этот промис исполнен').then(function (value) {
  console.log(value); // "Этот промис исполнен"
});

const happyDog = Promise.resolve('happy');
happyDog.then(function (dog) {
  console.log(dog); // happy
});

//# Promise.reject()
// Если вы сразу хотите создать исполненный или отклонённый промис, вызывать new Promise необязательно. Можно обратиться к методам Promise.resolve и Promise.reject. Эти методы создают промис, переводят его в статус «исполнен» или «отклонён» соответственно, и записывают как результат промиса — то, что мы передали этим методам.
Promise.reject('Этот промис отклонён').catch(function (value) {
  console.log(value); // "Этот промис отклонён"
});

const sadDog = Promise.reject('happy');
sadDog.catch(function (dog) {
  console.log(dog); // happy
});

//# Promise.all()
// принимает на вход массив с промисами и выполняет записанный в then код, только когда все промисы вернулись со статусом «исполнен».
//* Создаём первый промис
const firstPromise = new Promise((resolve, reject) => {
  if (someCondition) {
    resolve('Первый промис');
  } else {
    reject();
  }
});
//* Создаём второй промис
const secondPromise = new Promise((resolve, reject) => {
  if (secondCondition) {
    resolve('Второй промис');
  } else {
    reject();
  }
});
//* Создаём массив с промисами
const promises = [firstPromise, secondPromise];
//* Передаём массив с промисами методу Promise.all
Promise.all(promises).then(results => {
  console.log(results); // ["Первый промис", "Второй промис"]
});
