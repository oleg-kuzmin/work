//# Типы данных
/*
- Типы 1-7 называются «примитивными», их значениями могут быть только простые значения. (Хранение по значению)
1) число            - number (для любых чисел, ограничены диапазоном ±(2 в 53 степени -1)
2) большое число    - bigInt (для целых чисел произвольной длины)
3) строка           - string (может содержать ноль или больше символов, нет отдельного символьного типа)
4) булевый тип      - boolean (true || false)
5) неизвестно       - null (для неизвестных значений)
6) неопределен      - undefined (для неприсвоенных значений)
7) символ           - symbol (для уникальных идентификаторов.)

- Тип 8 называется ссылочным, объекты, массивы и функции это все объекты. (Хранение по ссылке)
8) объект           - object (для более сложных структур данных.)
*/

//# number (Число)
/*
- Тип данных «число» (number) содержит числа с плавающей точкой в диапазоне от -(253 − 1) до 253 − 1, а также специальные значения Infinity, -Infinity и NaN.
- Для этого типа данных определены стандартные арифметические операции сложения +, вычитания -, умножения *, деления /, взятия остатка от целочисленного деления %, сравнения >, <, >=, <=, ==, ===
- В JavaScript отсутствует отдельный тип данных для целых чисел, для целых чисел также используется тип number.
- Сам по себе примитивный тип «число» не имеет методов. Когда происходит вызов метода у числа, оно автоматически оборачивается в специальную обёртку, которая и содержит методы.
- Для округления, взятия корней и других математических операций в JavaScript существует отдельный модуль Math.
*/

//# Число с плавающей точкой
/*
- Число в JavaScript представлено в виде 64-битного формата IEEE-754. Формат хранит произвольное число в виде трёх значений: 1 бит на знак числа, 52 бита значения числа и ещё 11 бит местоположения точки. С таким подходом можно эффективно хранить значения в большом диапазоне от -(253 − 1) до 253 − 1.
- Из-за того, что положение точки в числе хранится отдельным значением, формат и называется числом с плавающей точкой (floating point number).
- Проблема этого представления в том, что оно не может представить числа абсолютно точно, а только с некоторой погрешностью.
/*

//# Неточные вычисления
/*
- В десятичной системе счисления есть числа, которые не могут быть записаны точно. Например, треть ¹⁄₃ записывается как бесконечная дробь 0.33(3).
- Компьютер хранит данные в двоичном виде — наборе нулей и единиц. В этой системе счисления тоже есть дроби, которые не могут быть записаны точно. В этом случае формат округляет значение до ближайшего представимого. При арифметических операциях эти неточности складываются и приводят к эффектам, подобным этому: console.log(0.2 + 0.7) // 0.8999999999999999
- Это не ошибка JavaScript, а фундаментальная особенность хранения дробных чисел в памяти компьютера, с ней нужно уметь работать. Для уменьшения эффекта используется комбинация подходов — использовать как можно меньше дробных значений, а когда этого невозможно избежать — округлять числа, тем самым сбрасывая накопившийся остаток.
- Например, если ваша система работает с деньгами, то лучше хранить цены в копейках или центах. Это позволит избежать большого количества операций с дробями. Для вывода цен можно пользоваться методом toFixed, который округлит число до указанного разряда:
- Похожую проблему можно наблюдать при сравнении очень маленьких и очень больших чисел. В таких случаях из-за округления точность теряется и различные числа компьютер представляет одинаковыми.
*/

//# Специальные значения
/*
- Стандарт IEEE-754 определяет три специальных значения. Эти значения принадлежат типу number, но не работают, как обычные числа:
1) Infinity (бесконечность)
2) -Infinity (минус бесконечность)
3) NaN (не число - not a number)

- Бесконечности используются, чтобы определить результат некоторых арифметических операций.
- Например, деление на ноль в JavaScript вернёт бесконечность.
- Если попытаться создать число, которое находится вне диапазона доступных чисел, результатом будет тоже бесконечность.

- Значение NaN используется, чтобы сообщить об операции, результатом которой оказалось не число.
- В JavaScript существует пять операций, которые могут вернуть NaN:
1) ошибка парсинга числа (например, при попытке превратить строку в число parseInt('привет'))
2) результат математической операции не находится в полей действительных чисел (например, взятие корня от -1)
3) один из операндов в арифметической операции — NaN (5 + NaN)
4) результат арифметической операции не определён для переданных операндов (undefined + undefined)
5) арифметическая операция со строкой, кроме сложения ('привет' * 5)

- Согласно спецификации, NaN не равен самому себе. Проверить, что в переменной хранится NaN простым сравнением не получится
- Для проверки на NaN пользуйтесь функцией Number.isNaN(), которая возвращает true если переданное значение — NaN.
- Для проверки, что значение в переменной является конечным числом, а не специальным значением, пользуйтесь функцией Number.isFinite(), она возвращает true, если переданный аргумент — число.
*/

//* для записи чисел используются цифры, для разделения целой и десятичной части используется точка
const int = 4;
const decimal = 0.101;
const sameDecimal = 0.101;

//* можно использовать экспоненциальную запись, например, один миллион в экспоненциальной записи
const scientific = 1e6; // 1000000

//* числа так же могут быть представлены в двоичном, восьмеричном или шестнадцатеричном виде. Такие числа начинаются с приставки 0b, 0o, 0x соответственно. При выводе на экран они будут преобразованы в десятичную систему счисления
const binary = 0b11; // 3
const octal = 0o77; // 63
const hexadecimal = 0xff; // 255

//* бесконечность Infinity
console.log(5 / 0); // деление на 0 - это бесконечность (Infinity)
console.log(-3 / 0); // если разделить на 0 отрицательное число получим минус бесконечность (-Infinity)
console.log(Infinity - 1000000000); // бесконечность минус что угодно — бесконечность (Infinity)
console.log(Infinity + -Infinity); // NaN
console.log(Infinity * 0); // NaN
console.log(Infinity * -1); // -Infinity
console.log(Infinity * -Infinity); // -Infinity

//* не число (not a number) NaN
const result = NaN;
console.log(Number.isNaN(result)); // true
console.log(typeof NaN); // "number"
console.log(NaN === NaN); // false

//* неточные вычисления
console.log(0.2 + 0.7); // 0.8999999999999999

//* сравнение очень маленьких и очень больших чисел
const small = 0.11111111111111111;
const smaller = 0.1111111111111111;
console.log(small.toFixed(20)); // 0.11111111111111110494
console.log(smaller.toFixed(20)); // 0.11111111111111110494
console.log(small === smaller); // true

//* операции с числами
const a = 5;
const b = 10;
console.log(-a); // -5
console.log(a + b); // 15
console.log(a - b); // -5
console.log(a / b); // 0.5
console.log(a * b); // 50
console.log((a + b) / 10); // 1.5

//* оператор взятия остатка от деления
console.log(5 % 2); // 1
console.log(5 % 3); // 2
console.log(5 % 5); // 0

//* возведение в степень
console.log(2 ** 4); // 16

//* операторы сравнения, возвращают булевое значение
console.log(5 > 10); // false
console.log(5 >= 10); // false
console.log(5 < 10); // true
console.log(10 <= 10); // true
console.log(5 == 10); // false
console.log(5 === 10); // false
console.log(5 != 10); // true
console.log(5 !== 10); // true

//* числовой разделитель
const number = 1_000_000; // 1000000
const binary2 = 0b0101_1111_0001;
const hex = 0x12_ab_34_cd;
const bigInt = 1_234_567_890n;

//# bigInt
/*
- Тип большого целого BigInt — примитивный тип, который представляет целые числа больше 253-1. Эти числа уже не помещаются в стандартный примитив «число».
- Этот тип может использоваться для работы с произвольно большими целыми числами.
- BigInt не сериализуется в JSON. Это усложняет использование этого типа данных в задачах взаимодействия с сервером.
*/

//# Создать BigInt можно двумя способами
//* добавить суффикс n в конец записи числа
const biggy = 9997000254740991n;

//* вызвать конструктор BigInt
const alsoBig = BigInt(9997000254999999);

//# математические операции
// Для BigInt определены операции сложения "+", вычитания "-", умножения "*", взятия остатка от деления "%", возведение в степень "**". Операция деления "/" также работает, но дробная часть будет отброшена.

const seven = 7n;
const five = 5n;
console.log(seven / five); // 1

//# string (Строка)
/*
- Любые текстовые данные в JavaScript — это строки (англ. string).
- Строки представляют собой последовательность символов.
- Созданная строка является иммутабельной (immutable) и не может быть изменена.
- Для строк определена операция сложения, её также называют конкатенацией строк. При сложении двух строк получается новая строка, склеенная из исходных.
- Строки можно сравнивать между собой, для сравнения используется лексикографический порядок. Это означает, что первые символы алфавита считаются меньше последних.
- Сам по себе примитивный тип «строка» не имеет методов. Когда происходит вызов метода, строка автоматически оборачивается в специальную обёртку, которая и содержит методы.
*/

//* одинарные или двойные кавычки
const single = 'Солнце высушивало мокрые лица домов напротив моего окна';

//* шаблонная строка
const phrase = `Обратные кавычки позволяют встраивать переменные ${str}`;

//* конкатенацией строк
const desire = 'Я хочу';
const food = 'пельменей';
const good = desire + ' ' + food; // Я хочу пельменей

//* экранировка символа
// Если в записи одинарными кавычками нужно поставить апостроф, то символ экранируют обратным слэшем \.
// Так мы даём JavaScript понять, что это просто символ, а не закрывающая кавычка
const who = "I'm a good person."; // или 'I\'m a good person.'

//* специальные символы
// \n — начало новой строки \t — табуляция, аналогично нажатию кнопки Tab
const newPhrase = 'Мы —\n\tЭдисоны\n\t\tневиданных взлётов,\n\t\t\tэнергий\n\t\t\t\tи светов.';

//* получение символа строки по индексу
console.log('эспрессо'[0]); // э
console.log('экспрессо'[20]); // undefined

//# boolean (Булев тип)
/*
- Логический или булев тип boolean может принимать лишь истинное (true) и ложное (false) значения. Назван он так в честь Джорджа Буля, одного из основателей математической логики.
- Значения этого типа используются в условных выражениях.
- Обычно логическим переменным дают названия, начинающиеся с английских глаголов is, should, does, can и подобных.
*/

//# пример
//* первый способ создания — явно указать значение, используя ключевые слова true и false
const truthyValue1 = true; // Истина
const falsyValue1 = false; // Ложь

//* второй способ создания — использовать метод Boolean
const truthyValue2 = Boolean(1); // «Истина»
const falsyValue2 = Boolean(''); // «Ложь»

//* третий способ — использовать выражения, значениями которых будут «истина» или «ложь»
const truthyValue3 = Boolean(4 < 5); // true
const anotherTruthy3 = 4 < 5; // true
const falsyValue3 = Boolean(2 * 2 === 5); // false
const anotherFalsy3 = 2 * 2 === 5; // false

//# null (Неизвестное значение)
/*
- Null — это примитивный тип данных, который состоит из единственного значения null.
- Значение null используют, когда нужно обозначить намеренное отсутствие значения.
- null обозначает понятия «отсутствует», «ничего», «пусто» или «значение неизвестно». Оно всегда явно задаётся программистом, JavaScript автоматически не устанавливает его.
- В JavaScript null используется только для обозначения конца цепочки прототипов, чтобы показать, что следующий прототип отсутствует.
- В языке существует похожий примитив undefined, он обозначает, что значение ещё не установлено. Их можно легко спутать, потому что оба обозначают отсутствие значения. Разница состоит в том, что null обозначает намеренное отсутствие, а undefined неявное.
- Например, сам JavaScript использует undefined для обозначения не проинициализированных переменных.
*/

//* намеренное отсутствие значения
let password = null;

//# undefined (Неопределённое значение)
/*
- Undefined — это примитивный тип данных, состоящий из одного значения undefined. Оно используется, чтобы обозначить неизвестное или неопределённое значение.
- Но будьте аккуратны, когда устанавливаете undefined свойствам объектов. Если у объекта удалить свойство, то при обращении к несуществующему свойству также вернётся undefined.
- undefined обозначает, что значение по каким-то причинам ещё не установлено или неизвестно. В этом контексте его использует сам язык JavaScript.
- В языке существует похожий примитив null. Он обозначает, что значение отсутствует. undefined и null можно легко спутать, потому что это близкие понятия. Различие состоит в том, что null обозначает отсутствие значения, а undefined — что значение неизвестно или не задано.
*/

//* js автоматически устанавливает значение undefined объявленным переменным, которые не были проинициализированы значением
let userName;
console.log(userName); // undefined (в Chrome и Safari)
console.log(userName); // undefined (в Firefox)

//* js автоматически устанавливает значение undefined в аргумент функции, если значение не передали при вызове
function hello(name) {
  console.log('Привет, ' + name);
}
hello('Витя'); // Привет, Витя
hello(); // Привет, undefined

//* вручную установленное undefined используют, чтобы обозначить неизвестное значение
const person = {
  name: 'Пётр',
  lastName: 'Романов',
  age: undefined,
};

//# symbol
/*
- Символ (Symbol) — примитивный тип, значения которого создаются с помощью вызова функции Symbol. Каждый созданный символ уникален.
- Символы могут использоваться в качестве имён свойств в объектах. Символьные свойства могут быть прочитаны только при прямом обращении и не видны при обычных операциях.
- Символы используются для создания скрытых свойств объектов. В отличие от свойств, ключом которых является строка, символьные свойства может читать только владелец символа. Скрытые свойства не видны при его обходе с помощью for...in:
- Это может пригодиться, когда необходимо добавить свойства объекту, который могут модифицировать другие части программы. Таким образом только вы сможете читать созданное свойство, а гарантия уникальности символов гарантирует и отсутствие конфликтов имён.
*/

//# Создание
// Для создания символа нужно вызвать функцию Symbol. Создание символа через конструктор new Symbol() не поддерживается.
// При создании символа первым аргументом можно передать его описание (const mySym = Symbol('name')). Оно ни на что не влияет и необходимо только для отладки. Даже если описания символов совпадают, JavaScript всё равно создаёт уникальные символы.
const sym = Symbol();
const symTwo = Symbol();
console.log(sym === symTwo); // false

//# Использование
const secondaryId = Symbol();
const user = {
  id: 193,
  name: 'Ольга',
  [secondaryId]: 'olga-1',
};
console.log(user[secondaryId]); // olga-1

//# Глобальный реестр символов
/*
- Созданный символ уникален, но как быть, если он нужен в нескольких местах программы? Для решения этой проблемы существует глобальный реестр символов, он хранит символы по строковым ключам. При обращении по ключу всегда будет возвращаться один и тот же символ.

- Работа с реестром символов организована с помощью двух методов:
Symbol.for(ключ) — возвращает символ, хранящийся по ключу. Если символа ещё не существует, он создаётся автоматически.
Symbol.keyFor(символ) — возвращает строковый ключ, который хранит переданный символ или undefined, если символ не хранится в реестре.
*/

const newSym = Symbol.for('registryKey');
const newestSym = Symbol.for('registryKey');
console.log(newSym === newestSym); // true

user[newSym] = 'hello';
console.log(Symbol.keyFor(newSym)); // registryKey
