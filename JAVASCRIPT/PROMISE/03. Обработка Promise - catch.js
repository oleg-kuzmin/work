//# Обработка Promise - catch
/*
- Отработает ошибку от вышестоящих then. Если все в порядке, то catch вообще не выполнится. Но если любой из промисов будет отклонён (проблемы с сетью или некорректная json-строка, или что угодно другое), то ошибка будет перехвачена. 
- Вокруг функции промиса и обработчиков находится "невидимый try..catch"
- Это работает не только в функции промиса, но и в обработчиках. Если мы бросим ошибку (throw) из обработчика (.then), то промис будет считаться отклонённым, и управление перейдёт к ближайшему обработчику ошибок.
*/

//# Синтаксис
promise.catch(function (error) {
  /**
   * обработает ошибку
   * .catch(f) это то же самое, что promise.then(null, f)
   */
});

//* function (error)

//# Проброс ошибок
// Если мы пробросим (throw) ошибку внутри блока .catch, то управление перейдёт к следующему ближайшему обработчику ошибок. А если мы обработаем ошибку и завершим работу обработчика нормально, то продолжит работу ближайший успешный обработчик .then.

//* Обработка ошибки
new Promise((resolve, reject) => {
  throw new Error('Ошибка!');
})
  .catch(function (error) {
    alert('Ошибка обработана, продолжить работу');
  })
  .then(() => alert('Управление перейдёт в следующий then'));

//* Проброс ошибки
new Promise((resolve, reject) => {
  throw new Error('Ошибка!');
})
  .catch(function (error) {
    if (error instanceof URIError) {
      // обрабатываем ошибку
    } else {
      alert('Не могу обработать ошибку');
      // пробрасывает эту или другую ошибку в следующий catch
      throw error;
    }
  })
  .then(function () {
    /* не выполнится */
  })
  .catch(error => {
    // ничего не возвращаем => выполнение продолжается в нормальном режиме
    alert(`Неизвестная ошибка: ${error}`);
  });
