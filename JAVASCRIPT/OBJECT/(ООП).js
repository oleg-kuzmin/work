//# (ООП)
//* наследование
// Наследование помогает оптимизировать код за счёт возможности создания новых классов на основе старых.

//* инкапсуляция
// Инкапсуляция повышает общую надёжность приложения за счёт хранения данных и функциональности в одном месте и защите этих данных от внешнего вмешательства.

//* полиморфизм
// Полиморфизм отвечает за возможность расширения классов с помощью новой функциональности или переопределения старой.

//# (СОЗДАНИЕ КЛАССА)
/*
- Конструктор нужно объявлять только когда для создания объекта необходимы входные данные или если при создании объекта нужно производить вычисления.
- Иначе описывать метод constructor необязательно. В таком случае конструктор будет создан неявно и с пустым телом: constructor() {}. После этого, даже если некоторые данные будут переданы в момент создания класса, они не будут обработаны.
*/

//* класс Song
class Song {
  constructor(name, artist) {
    this.name = name;
    this.artist = artist;
    this.isLiked = false;
  }

  like() {
    this.isLiked = !this.isLiked;
  }
}

//* наследование полей
/*
- Важно запомнить, что если класс наследуется через extends и в нём нужно определить метод constructor, — в самом начале тела конструктора необходимо вызвать super и передать ему нужные свойства. В противном случае появится ошибка и скрипт перестанет выполняться.
- Такой подход позволяет избежать дублирования кода в конструкторе наследника: логика заполнения полей name и cohort уже есть в родительском конструкторе и мы можем воспользоваться ей с помощью ключевого слова super.
*/

class SongRock extends Song {
  constructor(name, artist) {
    super(name, artist, isLiked);
    this.genre = 'Rock';
  }
}

//* переопределение метода (полиморфизм)
class SongRock extends Song {
  constructor(name, artist) {
    super(name, artist, isLiked);
    this.genre = 'Rock';
  }

  like() {
    console.log('Новая логика');
  }
}

//* расширение метода (полиморфизм)
class DesignerStudent extends Student {
  constructor(name, cohort) {
    super(name, cohort);
    this.profession = 'Designer';
    this.trainingDuration = 6;
  }

  getInfo() {
    const info = super.getInfo(); // наследуем метод родителя
    delete info.language; // добавляем новый функционал
    return info; // добавляем новый функционал
  }
}

//* приватные поля
/*
- Для объявления приватного свойства достаточно  поставить перед его названием символ #.
- Все приватные поля необходимо объявить заранее, до конструктора.
*/

class Song {
  #genre;

  constructor(name, artist) {
    this.name = name;
    this.artist = artist;
    this.isLiked = false;
    this.#genre = 'Rock';
  }

  like() {
    this.isLiked = !this.isLiked;
  }

  #getGenre() {
    return this.#genre;
  }
}

//# (СОЗДАНИЕ ЭКЗЕМПЛЯРА КЛАССА)
//* экземпляр класса Song
const song = new Song('Start Over', 'Any Given Day'); // constructor(name, artist)

/*
- Любую функцию в JavaScript можно вызвать с ключевым словом new перед вызовом:
const song = new createSong('На заре', 'Альянс');
- Функции, предназначенные для того, чтобы их вызывали с оператором new, называют функциями-конструкторами. Их основная задача: «сконструировать» какой-то новый объект.
- Чтобы понять что функцию нужно вызывать с оператором new и что перед нами функция-конструктор ее называют с прописной буквы. Также, функцию-конструктор обычно называют существительным.

- Если движок натыкается на такой вызов, он начинает исполнять код внутри этой функции, но дополняет стандартный процесс исполнения кода двумя шагами (1 и 3 в списке):
1. Перед тем, как исполнять код, создаёт новый пустой объект и записывает его в значение this внутри этой функции.
2. Исполняет код функции.
3. Возвращает this.

- Во время создания экземпляра в скобках вы можете передать классу любые аргументы. Все эти аргументы передаются прямо в конструктор, где вы можете их обработать.
*/
