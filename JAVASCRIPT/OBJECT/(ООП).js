//# (ООП)
//* наследование
// Наследование помогает оптимизировать код за счёт возможности создания новых классов на основе старых.

//* инкапсуляция
// Инкапсуляция повышает общую надёжность приложения за счёт хранения данных и функциональности в одном месте и защите этих данных от внешнего вмешательства.

//* полиморфизм
// Полиморфизм отвечает за возможность расширения классов с помощью новой функциональности или переопределения старой.

//# (СОЗДАНИЕ КЛАССА)
/*
- Конструктор нужно объявлять только когда для создания объекта необходимы входные данные или если при создании объекта нужно производить вычисления.
- Иначе описывать метод constructor необязательно. В таком случае конструктор будет создан неявно и с пустым телом: constructor() {}. После этого, даже если некоторые данные будут переданы в момент создания класса, они не будут обработаны.
*/

//* класс Song
class Song {
  constructor(name, artist) {
    this.name = name;
    this.artist = artist;
    this.isLiked = false;
  }

  like() {
    this.isLiked = !this.isLiked;
  }
}

//* наследование
/*
- Важно запомнить, что если класс наследуется через extends и в нём нужно определить метод constructor, — в самом начале тела конструктора необходимо вызвать super и передать ему нужные свойства. В противном случае появится ошибка и скрипт перестанет выполняться.
- Такой подход позволяет избежать дублирования кода в конструкторе наследника: логика заполнения полей name и cohort уже есть в родительском конструкторе и мы можем воспользоваться ей с помощью ключевого слова super.
*/

class SongRock extends Song {
  constructor(name, artist) {
    super(name, artist, isLiked);
    this.genre = 'Rock';
  }
}

//# (СОЗДАНИЕ ЭКЗЕМПЛЯРА КЛАССА)
//* экземпляр класса Song
const song = new Song('Start Over', 'Any Given Day'); // constructor(name, artist)

// Во время создания экземпляра в скобках вы можете передать классу любые аргументы. Все эти аргументы передаются прямо в конструктор, где вы можете их обработать.
