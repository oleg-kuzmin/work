//# eventName (Варианты событий)
// Событие, на которое нужно отреагировать. Передаётся строкой: 'click', 'scroll', 'mouseover'.

//# blur
// Срабатывает, если пользователь переключил вкладку

//# change
// Срабатывает только когда поле изменилось и пользователь перешёл к другому элементу формы. Пригодится, когда пользователь пропустил поле и ничего не заполнил.

//# click
// Клик по элементу левой кнопкой, но только если она нажата и отпущена на элементе. То есть click происходит, когда на элементе друг за другом сработали mousedown и mouseup, но обязательно левой кнопкой мыши.

//# contextmenu
// Возникает при щелчке правой кнопкой, когда она в нижнем положении. Как mousedown, но для одной правой кнопки.

//# dblclick
// Возникает при двойном щелчке левой кнопкой. Обработчик отслеживает два срабатывания click подряд на одном элементе.

//# DOMContentLoaded
/*
- Событие DOMContentLoaded происходит, когда браузер разобрал HTML-страницу и составил DOM-дерево.
- Если нужно, чтобы страница обязательно загрузилась полностью, лучше присмотреться к load.
- Чтобы показать пользователю страницу, браузер делает следующие первые шаги:
1) Запрашивает HTML-страницу с сервера;
2) Затем обрабатывает полученный HTML и создаёт DOM для взаимодействия между JavaScript и HTML (в конце этого этапа происходит событие DOMContentLoaded).
- Событие DOMContentLoaded происходит раньше события load и гарантирует, что DOM готов. Можно искать по нему узлы и не бояться, что что-то не догрузилось (кроме стилей, картинок и так далее).
- Основной сценарий использования DOMContentLoaded: инициализация интерфейса и первые обращения к серверу.
- Нормальной практикой считается запуск всего приложения в момент срабатывания DOMContentLoaded, таким образом исключается случай, когда DOM ещё не догрузился, а приложение уже ищет по нему узлы.
*/
document.addEventListener('DOMContentLoaded', function () {
  console.log('DOM готов!');
});

//# input
// Срабатывает при вводе или удалении каждого символа.

//# keydown
// Клавиша нажата. Сработает на любой клавише в тот момент, когда на неё нажмут. В таких случаях говорят, что клавиша «в нижнем положении».

//# keypress
// Нажатие на клавишу. Cработает при нажатии, но проигнорирует клавиши-модификаторы: alt, ctrl, shft и win — на Windows, и control, option, shift и command — на macOS.

//# keyup
// Клавиша отпущена. Сработает на любой клавише, но только когда её отпустят.

//# load
/*
- Событие load происходит, когда загрузилась и HTML страница (за это отвечает событие DOMContentLoaded), и все ресурсы для её отображения пользователю: стили, картинки и другое.
- Событие load гарантирует, что браузер отображает страницу полностью: все стили и картинки готовы, размеры элементов на странице посчитаны верно и доступны. Предшествующее load событие DOMContentLoaded таких гарантий не даёт. То же самое с отдельными элементами на странице: если случился load, значит элемент полностью загрузился.
- Чаще применяют DOMContentLoaded. Событие load используется, когда код работает со стилями и другими параметрами отображения. Такой код нужен редко, поэтому и событие используется нечасто.
*/
window.addEventListener('load', function () {
  console.log('Страница готова!');
});

//# mousedown
// Возникает при щелчке мышью, когда кнопка в нижнем положении. События mousedown и mouseup срабатывают на все кнопки мыши: левую, правую и нажатие на колёсико. Они полезны для создания Drag'n'Drop — интерфейса, в котором элемент можно схватить и перетащить на другое место.

//# mouseout
/*
- Пользователь убрал указатель мыши с элемента.
- С помощью пары событий mouseover и mouseout можно делать выпадающие списки и меню. Но у таких меню могут быть проблемы с доступностью.
- Есть очень похожее событие mouseenter, но оно не всплывает. Вместо этого для каждого элемента в цепочке вложенности (с самого вложенного элемента, на котором произошло событие до <body>) создаётся собственное событие. Если у вас глубокое DOM-дерево, то таких событий может быть много. Это может привести к проблемам с производительностью.
*/

//# mouseover
/*
- Пользователь навёл указатель мыши на элемент.
- С помощью пары событий mouseover и mouseout можно делать выпадающие списки и меню. Но у таких меню могут быть проблемы с доступностью.
- Есть очень похожее событие mouseenter, но оно не всплывает. Вместо этого для каждого элемента в цепочке вложенности (с самого вложенного элемента, на котором произошло событие до <body>) создаётся собственное событие. Если у вас глубокое DOM-дерево, то таких событий может быть много. Это может привести к проблемам с производительностью.
*/

//# mouseup
/*
- Возникает при щелчке мышью, когда кнопка отпущена).
- При этом важно, только где она была отпущена, а не где нажата.
- Поэтому событие сработает, если щёлкнуть в произвольном месте, удерживать кнопку, навести на элемент и затем её отпустить.
- Событие mouseup сработает по-особенному для клика правой кнопкой: по умолчанию оно вызывает контекстное меню, в котором пользователь может скопировать текст, изображение или посмотреть код.
- События mousedown и mouseup срабатывают на все кнопки мыши: левую, правую и нажатие на колёсико. Они полезны для создания Drag'n'Drop — интерфейса, в котором элемент можно схватить и перетащить на другое место.
*/

//# scroll
/*
- Пользователь прокручивает страницу или элемент в любой плоскости.
- Чтобы понять, насколько прокрутилась страница или элемент, этот элемент получают из DOM-дерева или ключевого слова this и запрашивают свойства scrollTop или scrollLeft.
*/
document.addEventListener('scroll', function (event) {
  console.log(event);
});
document.addEventListener('scroll', function () {
  // получаем высоту элемента, на котором произошло событие
  console.log(this.scrollTop);
});

//# submit
/*
- Событие submit возникает, когда пользователь отправляет валидную форму. Если форма невалидна и её нельзя отправить, то и submit не будет.
- За отправкой формы лучше всегда наблюдать через подписку именно на событие submit.
- Это удобнее и правильнее, ведь submit связан сразу с каждым элементом формы, а пользователь может отправить её разными способами. Например, нажать на клавишу Enter в поле ввода и не трогать вовсе красивую кнопку подтверждения. В то же время подписка на другие события, например на click по кнопке, будет лишь косвенно связано с отправкой формы.
- При отправке формы браузер «синтетически» кликает по кнопке на случай, если какое-то действие привязано к ней, а не к submit.
- Функция-обработчик срабатывает в момент отправки формы, когда все обязательные поля заполнены. К сожалению, при успешной отправке формы и отсутствующем атрибуте action страница перезагружается — это называется стандартным событием.
- Чтобы такого поведения не происходило — передайте в функцию-обработчик параметр evt. В самом начале тела функции вызовите метод evt.preventDefault() — это отменит стандартное событие.
*/
