//# Асинхронные функции
/*
- Асинхронная функция помечается специальным ключевым словом async
- У слова async один простой смысл: эта функция всегда возвращает промис. Значения других типов оборачиваются в завершившийся успешно промис автоматически.

- Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится. После чего оно вернёт его результат, и выполнение кода продолжится. Await можно использовать только внутри async–функций.

Плюсы async/await
- Код чище и короче. У нас больше нет цепочек из then(), вместо этого мы получаем плоскую структуру, которая по виду похожа на синхронный код. Условия и вложенные конструкции становятся чище и проще читаются.
- Мы можем обрабатывать ошибки с try-catch. Как и с синхронным кодом, обработка ошибок сводится к оборачиванию опасных операций в try-catch.
- Можно ставить брейкпоинты (точки останова). Для отладки мы можем поставить брейкпоинт куда угодно, он сработает.
*/

//# Создание функции
//* обычная функция
async function request() {}

//* стрелочная функция
const req = async () => {};

//* class
class SomeClass {
  async request() {}
}

//# Вызов функции
//* сработает Promise
request().then(() => {});

//# await внутри
// Внутри асинхронных функций можно вызывать другие асинхронные функции, без каких-либо then() или колбэков, с помощью ключевого слова await. Все асинхронные функции внутри мы вызываем с await — таким образом промис, который функция возвращает, автоматически разворачивается, и мы получаем значение, которое внутри промиса было.

async function loadPosts() {
  const response = await fetch('/api/posts/');
  const data = await response.json();
  return data;
}

//# try-catch
// В отличие от .catch() промисов, try-catch поймает не только ошибки, которые были внутри асинхронных функций, но также и ошибки, которые возникли во время обычных синхронных операций.

async function loadPosts() {
  try {
    const response = await fetch('/api/posts/');
    const data = await response.json();
    return data;
  } catch (error) {
    console.log(error);
  }
}

//# Promise.all
// Запустив getNews параллельно c getUser, мы в большинстве случаев получим результат быстрее. Promise.all() позволяет запустить запросы параллельно, при этом дожидаться результата мы можем как и раньше при помощи await.

const [user, news] = await Promise.all([getUser(), getNews()]);
