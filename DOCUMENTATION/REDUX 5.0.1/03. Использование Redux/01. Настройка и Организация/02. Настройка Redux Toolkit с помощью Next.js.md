# Настройка Redux Toolkit с помощью Next.js

**ЧТО ВЫ УЗНАЕТЕ**

- Как настроить и использовать Redux Toolkit с инфраструктурой [Next.js](https://nextjs.org/docs)

**Пререквизит**

- Знание синтаксиса и функций ES2015.
- Знание терминологии React: [JSX](https://reactjs.org/docs/introducing-jsx.html), [состояние](https://reactjs.org/docs/state-and-lifecycle.html), [функциональные компоненты, пропсы](https://reactjs.org/docs/components-and-props.html) и [хуки](https://reactjs.org/docs/hooks-intro.html).
- Понимание [терминов и концепций Redux](https://redux.js.org/tutorials/fundamentals/part-2-concepts-data-flow).
- Рекомендуется проработать [руководство по быстрому запуску](https://redux.js.org/tutorials/quick-start) и [руководство по быстрому запуску TypeScript](https://redux.js.org/tutorials/typescript-quick-start), а в идеале - также полное руководство по [Redux Essentials](https://redux.js.org/tutorials/essentials/part-1-overview-concepts).

## Введение

Next.js — это популярная платформа рендеринга на стороне сервера для React, которая создает некоторые уникальные проблемы при правильном использовании Redux. Эти проблемы включают в себя:

- **Безопасное создание хранилища Redux по каждому запросу**: сервер Next.js может обрабатывать несколько запросов одновременно. Это означает, что хранилище Redux должно создаваться для каждого запроса и что хранилище не должно использоваться совместно между запросами.
- **Гидратация хранилища с поддержкой SSR**: приложения Next.js обрабатываются дважды: сначала на сервере, а затем на клиенте. Неспособность отобразить одно и то же содержимое страницы как на клиенте, так и на сервере приведет к «ошибке гидратации». Таким образом, хранилище Redux придется инициализировать на сервере, а затем повторно инициализировать на клиенте с теми же данными, чтобы избежать проблем с гидратацией.
- **Поддержка маршрутизации SPA**: Next.js поддерживает гибридную модель маршрутизации на стороне клиента. При первой загрузке страницы клиент получит от сервера результат SSR. Последующая навигация по страницам будет осуществляться клиентом. Это означает, что при использовании одноэлементного хранилища, определенного в макете, данные, специфичные для маршрута, необходимо будет выборочно сбрасывать при навигации по маршруту, в то время как данные, не специфичные для маршрута, необходимо будет сохранять в хранилище.
- **Удобство кэширования на сервере**: последние версии Next.js (в частности, приложения, использующие архитектуру App Router) поддерживают агрессивное кэширование на сервере. Идеальная архитектура магазина должна быть совместима с этим кэшированием.

Существует две архитектуры приложения Next.js: [Pages Router](https://nextjs.org/docs/pages/building-your-application/routing/pages-and-layouts) и [App Router](https://nextjs.org/docs/app/building-your-application/routing)

Pages Router — это оригинальная архитектура Next.js. Если вы используете Pages Router, настройка Redux в основном выполняется с помощью библиотеки [next-redux-wrapper](https://github.com/kirill-konshin/next-redux-wrapper), которая интегрирует хранилище Redux с методами выборки данных Pages Router, такими как `getServerSideProps`.

**В этом руководстве основное внимание будет уделено архитектуре App Router**, поскольку это новый вариант архитектуры по умолчанию для Next.js.

## Как читать это руководство

На этой странице предполагается, что у вас уже есть приложение Next.js, основанное на архитектуре App Router.

Если вы хотите продолжить, вы можете создать новый пустой проект Next с помощью `npx create-next-app my-app` - подсказки по умолчанию установят новый проект с включенным App Router. Затем добавьте `@reduxjs/toolkit` и `react-Redux` в качестве зависимостей.

Вы также можете создать новый проект Next+Redux с помощью `npx create-next-app --example with-redux my-app`, который включает элементы начальной настройки, описанные на этой странице.

## Архитектура App Router и Redux

Основная новая функция Next.js: App Router - добавление поддержки серверных компонентов React (RSC). RSC - это особый тип компонента React, который отображается только на сервере, в отличие от «клиентских» компонентов, которые отображаются как на клиенте, так и на сервере. RSC можно определить как `асинхронные функции` и возвращать promise во время рендеринга, поскольку они делают асинхронные запросы данных для рендеринга.

Способность RSC блокировать запросы данных означает, что с помощью App Router у вас больше нет `getServerSideProps` для извлечения данных для рендеринга. Любой компонент дерева может выполнять асинхронные запросы данных. Хотя это очень удобно, это также означает, что если вы определите глобальные переменные (например, хранилище Redux), они будут использоваться в разных запросах. Это проблема, поскольку хранилище Redux может быть загрязнено данными других запросов.

Основываясь на архитектуре App Router, у нас есть следующие общие рекомендации по правильному использованию Redux:

- Нет глобальных хранилищ. Поскольку хранилище Redux используется совместно всеми запросами, его не следует определять как глобальную переменную. Вместо этого хранилище должно создаваться по запросу.
- RSC не должны читать или записывать хранилище Redux — RSC не могут использовать hooks или контекст. Они не предназначены для сохранения состояния. Чтение или запись значений RSC из глобального хранилища нарушает архитектуру маршрутизатора приложений Next.js.
- Хранилище должно содержать только изменяемые данные. Мы рекомендуем вам экономно использовать Redux для данных, которые должны быть глобальными и изменяемыми.

Эти рекомендации относятся только к приложениям, написанным с помощью маршрутизатора App Router Next.js. Одностраничные приложения (SPA) не выполняются на сервере и поэтому могут определять хранилища как глобальные переменные. SPA не нужно беспокоиться о RSC, поскольку их нет в SPA. А хранилища-одиночки могут хранить любые данные, которые вы захотите.

## Структура папок

Следующие приложения могут быть созданы с папкой `/app` либо в корне, либо вложенной в `/src/app`. Ваша логика Redux должна находиться в отдельной папке рядом с папкой `/app`. Логику Redux обычно помещают в папку с именем `/lib`, но это не обязательно.

Структура файлов и папок внутри этой папки `/lib` зависит от вас, но мы обычно рекомендуем структуру на основе [«папок фич»](https://redux.js.org/style-guide/#structure-files-as-feature-folders-with-single-file-logic) для логики Redux.

Типичный пример может выглядеть так:

```js
/app
  layout.tsx
  page.tsx
  StoreProvider.tsx
/lib
  store.ts
  /features
    /todos
      todosSlice.ts
```

Мы будем использовать этот подход для этого руководства.

## Начальная настройка

Как и в учебнике [RTK TypeScript](https://redux.js.org/tutorials/typescript-quick-start), нам нужно создать файл для хранилища Redux, а также предполагаемые типы `RootState` и `AppDispatch`.

Однако многостраничная архитектура Next требует некоторых отличий от настройки одностраничного приложения.

### Создание хранилища Redux по запросу

Первое изменение — перейти от определения `store` как глобальной или одноэлементной переменной модуля к определению функции `makeStore`, которая возвращает новое хранилище для каждого запроса:

```tsx
// lib/store.ts
import { configureStore } from '@reduxjs/toolkit';

export const makeStore = () => {
  return configureStore({
    reducer: {},
  });
};

// Определите тип makeStore
export type AppStore = ReturnType<typeof makeStore>;
// Выведите типы RootState и AppDispatch из самого store.
export type RootState = ReturnType<AppStore['getState']>;
export type AppDispatch = AppStore['dispatch'];
```

Теперь у нас есть функция `makeStore`, которую мы можем использовать для создания экземпляра хранилища для каждого запроса, сохраняя при этом строгую безопасность типов (если вы решите использовать TypeScript), которую обеспечивает Redux Toolkit.

У нас нет экспортированной переменной `store`, но мы можем вывести типы `RootState` и `AppDispatch` из типа возвращаемого значения `makeStore`.

Вам также понадобится создать и экспортировать [предварительно типизированные версии хуков React-Redux](https://redux.js.org/tutorials/typescript-quick-start#define-typed-hooks), чтобы упростить их использование в дальнейшем:

```tsx
// lib/hooks.ts
import { useDispatch, useSelector, useStore } from 'react-redux';
import type { AppDispatch, AppStore, RootState } from './store';

// Используйте во всем приложении вместо простых `useDispatch` и `useSelector`.
export const useAppDispatch = useDispatch.withTypes<AppDispatch>();
export const useAppSelector = useSelector.withTypes<RootState>();
export const useAppStore = useStore.withTypes<AppStore>();
```

## Предоставление store

Чтобы использовать эту новую функцию `makeStore`, нам нужно создать новый «клиентский» компонент, который будет создавать хранилище и делиться им с помощью компонента React-Redux `Provider`.

```tsx
'use client';
import { useRef } from 'react';
import { Provider } from 'react-redux';
import { makeStore, AppStore } from '../lib/store';

export default function StoreProvider({ children }: { children: React.ReactNode }) {
  const storeRef = useRef<AppStore>();
  if (!storeRef.current) {
    // Создайте экземпляр хранилища при первом рендеринге.
    storeRef.current = makeStore();
  }

  return <Provider store={storeRef.current}>{children}</Provider>;
}
```

В этом примере кода мы гарантируем, что этот клиентский компонент безопасен при повторной отрисовке, проверяя значение ссылки, чтобы гарантировать, что хранилище создается только один раз. Этот компонент будет отображаться только один раз для каждого запроса на сервере, но может быть повторно отображен на клиенте несколько раз, если над этим компонентом в дереве расположены клиентские компоненты с отслеживанием состояния, или если этот компонент также содержит другое изменяемое состояние, которое вызывает перерисовку.

**ПОЧЕМУ КЛИЕНТСКИЕ КОМПОНЕНТЫ?**

Следующим шагом будет **включение `StoreProvider` в любое место дерева выше, где используется хранилище**. Вы можете найти хранилище в компоненте макета, если оно требуется всем маршрутам, использующим этот макет. Или, если хранилище используется только на определенном маршруте, вы можете создать и предоставить хранилище в этом обработчике маршрута. Во всех клиентских компонентах ниже по дереву вы можете использовать хранилище точно так же, как обычно, используя hooks, предоставляемые `react-redux`.
