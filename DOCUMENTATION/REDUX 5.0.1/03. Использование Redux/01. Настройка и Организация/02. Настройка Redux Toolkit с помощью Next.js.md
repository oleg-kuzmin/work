# Настройка Redux Toolkit с помощью Next.js

**ЧТО ВЫ УЗНАЕТЕ**

- Как настроить и использовать Redux Toolkit с инфраструктурой [Next.js](https://nextjs.org/docs)

**Пререквизит**

- Знание синтаксиса и функций ES2015.
- Знание терминологии React: [JSX](https://reactjs.org/docs/introducing-jsx.html), [состояние](https://reactjs.org/docs/state-and-lifecycle.html), [функциональные компоненты, реквизиты](https://reactjs.org/docs/components-and-props.html) и [хуки](https://reactjs.org/docs/hooks-intro.html).
- Понимание [терминов и концепций Redux](https://redux.js.org/tutorials/fundamentals/part-2-concepts-data-flow).
- Рекомендуется проработать [руководство по быстрому запуску](https://redux.js.org/tutorials/quick-start) и [руководство по быстрому запуску TypeScript](https://redux.js.org/tutorials/typescript-quick-start), а в идеале — также полное руководство по [Redux Essentials](https://redux.js.org/tutorials/essentials/part-1-overview-concepts).

## Введение

Next.js — это популярная платформа рендеринга на стороне сервера для React, которая создает некоторые уникальные проблемы при правильном использовании Redux. Эти проблемы включают в себя:

- **Безопасное создание хранилища Redux по каждому запросу**: сервер Next.js может обрабатывать несколько запросов одновременно. Это означает, что хранилище Redux должно создаваться для каждого запроса и что хранилище не должно использоваться совместно между запросами.
- **Гидратация хранилища с поддержкой SSR**: приложения Next.js обрабатываются дважды: сначала на сервере, а затем на клиенте. Неспособность отобразить одно и то же содержимое страницы как на клиенте, так и на сервере приведет к «ошибке гидратации». Таким образом, хранилище Redux придется инициализировать на сервере, а затем повторно инициализировать на клиенте с теми же данными, чтобы избежать проблем с гидратацией.
- **Поддержка маршрутизации SPA**: Next.js поддерживает гибридную модель маршрутизации на стороне клиента. При первой загрузке страницы клиент получит от сервера результат SSR. Последующая навигация по страницам будет осуществляться клиентом. Это означает, что при использовании одноэлементного хранилища, определенного в макете, данные, специфичные для маршрута, необходимо будет выборочно сбрасывать при навигации по маршруту, в то время как данные, не специфичные для маршрута, необходимо будет сохранять в хранилище.
- **Удобство кэширования на сервере**: последние версии Next.js (в частности, приложения, использующие архитектуру App Router) поддерживают агрессивное кэширование на сервере. Идеальная архитектура магазина должна быть совместима с этим кэшированием.

Существует две архитектуры приложения Next.js: [Маршрутизатор Pages Router](https://nextjs.org/docs/pages/building-your-application/routing/pages-and-layouts) и [Маршрутизатор App Router](https://nextjs.org/docs/app/building-your-application/routing)

Pages Router — это оригинальная архитектура Next.js. Если вы используете Pages Router, настройка Redux в основном выполняется с помощью библиотеки [next-redux-wrapper](https://github.com/kirill-konshin/next-redux-wrapper), которая интегрирует хранилище Redux с методами выборки данных Pages Router, такими как `getServerSideProps`.

**В этом руководстве основное внимание будет уделено архитектуре App Router**, поскольку это новый вариант архитектуры по умолчанию для Next.js.

## Как читать это руководство

На этой странице предполагается, что у вас уже есть приложение Next.js, основанное на архитектуре App Router.

Если вы хотите продолжить, вы можете создать новый пустой проект Next с помощью `npx create-next-app my-app` — подсказки по умолчанию установят новый проект с включенным App Router. Затем добавьте `@reduxjs/toolkit` и `react-Redux` в качестве зависимостей.

Вы также можете создать новый проект Next+Redux с помощью `npx create-next-app --example with-redux my-app`, который включает элементы начальной настройки, описанные на этой странице.

## Архитектура App Router и Redux

Основная новая функция Next.js App Router — добавление поддержки серверных компонентов React (RSC). RSC — это особый тип компонента React, который отображается только на сервере, в отличие от «клиентских» компонентов, которые отображаются как на клиенте, так и на сервере. RSC можно определить как `асинхронные функции` и возвращать promise во время рендеринга, поскольку они делают асинхронные запросы на данные для рендеринга.

Способность RSC блокировать запросы данных означает, что с помощью App Router у вас больше нет `getServerSideProps` для извлечения данных для рендеринга. Любой компонент дерева может выполнять асинхронные запросы данных. Хотя это очень удобно, это также означает, что если вы определите глобальные переменные (например, хранилище Redux), они будут использоваться в разных запросах. Это проблема, поскольку хранилище Redux может быть загрязнено данными других запросов.

Основываясь на архитектуре App Router, у нас есть следующие общие рекомендации по правильному использованию Redux:

- Нет глобальных хранилищ. Поскольку хранилище Redux используется совместно всеми запросами, его не следует определять как глобальную переменную. Вместо этого хранилище должно создаваться по запросу.
- RSC не должны читать или записывать хранилище Redux — RSC не могут использовать hooks или контекст. Они не предназначены для сохранения состояния. Чтение или запись значений RSC из глобального хранилища нарушает архитектуру маршрутизатора приложений Next.js.
