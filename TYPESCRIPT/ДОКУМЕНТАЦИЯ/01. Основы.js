//# Основы
// Каждое значение в JavaScript имеет набор вариантов поведения, которые вы можете наблюдать при выполнении различных операций. Это звучит абстрактно, но в качестве быстрого примера рассмотрим некоторые операции, которые мы можем выполнить с переменной с именем message.

//* index.js
// Accessing the property 'toLowerCase'
// on 'message' and then calling it
message.toLowerCase();
// Calling 'message'
message();

// Если мы разберем этот пример, то первая работоспособная строка кода обращается к свойству toLowerCase а затем вызывает его. Вторая строка пытается вызвать message напрямую.

// Но если мы не знаем значения message (а это довольно часто встречается), мы не можем достоверно сказать, какие результаты мы получим при попытке запустить любой из этих кодов. Поведение каждой операции полностью зависит от того, какое значение мы имели изначально.

/*
- Можно ли вызвать message?
- Есть ли у него свойство toLowerCase?
- Если да, то можно ли его вызвать?
- Если оба этих значения являются вызываемыми, что они возвращают?
*/

// Ответы на эти вопросы обычно мы держим в голове, когда пишем JavaScript, и нам нужно надеяться, что мы правильно поняли все детали.

// Допустим, message было определено следующим образом.

const message = 'Hello World!';

// Как вы, наверное, догадались, если мы попытаемся запустить message.toLowerCase(), мы получим ту же строку, только в нижнем регистре.

// А как насчет второй строки кода? Если вы знакомы с JavaScript, вы знаете, что это не удается с исключением: TypeError: message is not a function.

// Было бы здорово, если бы мы могли избежать подобных ошибок.

// Когда мы запускаем наш код, среда выполнения JavaScript выбирает, что делать, путем выяснения типа значения — какие виды поведения и возможности оно имеет. Это часть того, на что это намекает TypeError: строка "Hello World!" не может быть вызвана как функция.

// Для некоторых значений, таких как примитивы string и number, мы можем определить их тип во время выполнения с помощью оператора typeof. Но для других вещей, таких как функции, не существует соответствующего механизма выполнения для определения их типов. Например, рассмотрим эту функцию:

function fn(x) {
  return x.flip();
}

// Прочитав код, мы можем заметить flip, и эта функция будет работать только в том случае, если ей дан объект с вызываемым свойством flip, но JavaScript не отображает эту информацию таким образом, чтобы мы могли проверить ее во время выполнения кода.Единственный способ в чистом JavaScript узнать, что происходит — это вызвать fn и посмотреть. Такое поведение затрудняет прогнозирование того, что будет делать код до его запуска, а это означает, что сложнее узнать, что будет делать ваш код, пока вы его пишете.

// С этой точки зрения тип — это концепция описания того, какие значения могут быть переданы fn, а какие приведут к сбою. JavaScript по-настоящему обеспечивает только динамическую типизацию — запуск кода, чтобы увидеть, что произойдет.

// Альтернативой является использование системы статических типов для прогнозирования того, что ожидается от кода перед его запуском.
