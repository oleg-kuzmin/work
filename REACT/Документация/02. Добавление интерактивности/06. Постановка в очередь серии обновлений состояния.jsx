//# Постановка в очередь серии обновлений состояния
// Установка переменной состояния ставит в очередь очередной рендеринг. Но иногда вы можете захотеть выполнить несколько операций над значением перед постановкой в очередь следующего рендера. Для этого необходимо понять, как React выполняет пакетную обработку обновлений состояния.

/* Вы узнаете
- Что такое "пакетная обработка" и как React использует ее для обработки нескольких обновлений состояния
- Как применить несколько обновлений к одной и той же переменной состояния подряд
*/

//# React собирает обновления состояния
// Вы можете ожидать, что нажатие кнопки "+3" увеличит счетчик три раза, потому что он вызывает setNumber(number + 1) три раза:

//* App.js
import { useState } from 'react';

function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 1);
          setNumber(number + 1);
          setNumber(number + 1);
        }}
      >
        +3
      </button>
    </>
  );
}

// Однако, как вы помните из предыдущего раздела, значения состояния каждого рендера фиксированы, поэтому значение number в обработчике событий первого рендера всегда 0, независимо от того, сколько раз вы вызовете setNumber(1):

setNumber(0 + 1);
setNumber(0 + 1);
setNumber(0 + 1);

// Но здесь есть еще один фактор. React ждет, пока не будет выполнен весь код в обработчиках событий, прежде чем обрабатывать ваши обновления состояния. Вот почему повторный рендеринг происходит только после всех этих вызовов setNumber().

// Это может напомнить вам официанта, принимающего заказ в ресторане. Официант не бежит на кухню при упоминании вашего первого блюда! Вместо этого он дает вам закончить заказ, позволяет вносить в него изменения и даже принимает заказы от других людей за столом.

// Это позволяет вам обновлять несколько переменных состояния - даже из нескольких компонентов - не вызывая слишком много повторных рендеров. Но это также означает, что пользовательский интерфейс не будет обновлен, пока после вашего обработчика событий и любого кода в нем не завершится. Такое поведение, также известное как батчинг, заставляет ваше приложение React работать намного быстрее. Оно также позволяет избежать путаницы с "полузаконченными" рендерами, в которых обновлены только некоторые переменные.

// React не выполняет пакетную обработку многочисленных намеренных событий, таких как клики - каждый клик обрабатывается отдельно. Будьте уверены, что React выполняет пакетную обработку только тогда, когда это в целом безопасно. Это гарантирует, что, например, если первое нажатие кнопки отключит форму, второе нажатие не отправит ее снова.

//# Обновление одного и того же состояния несколько раз до следующего рендера
// Это редкий случай использования, но если вы хотите обновить одну и ту же переменную состояния несколько раз до следующего рендера, вместо передачи значения следующего состояния, как setNumber(number + 1), вы можете передать функцию, которая вычисляет следующее состояние на основе предыдущего в очереди, как setNumber(n => n + 1). Это способ сказать React "сделать что-то со значением состояния" вместо того, чтобы просто заменить его.

// Попробуйте теперь увеличить счетчик:

//* App.js
import { useState } from 'react';

function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(n => n + 1);
          setNumber(n => n + 1);
          setNumber(n => n + 1);
        }}
      >
        +3
      </button>
    </>
  );
}

/* Здесь n => n + 1 называется функцией апдейтера. Когда вы передаете ее установщику состояния:
1. React ставит эту функцию в очередь на обработку после выполнения всего остального кода в обработчике событий.
2. Во время следующего рендеринга React просматривает очередь и выдает окончательное обновленное состояние.
*/

setNumber(n => n + 1);
setNumber(n => n + 1);
setNumber(n => n + 1);

/* Вот как React работает через эти строки кода при выполнении обработчика события:
1. setNumber(n => n + 1): n => n + 1 - это функция. React добавляет ее в очередь.
2. setNumber(n => n + 1): n => n + 1 - функция. React добавляет ее в очередь.
3. setNumber(n => n + 1): n => n + 1 - функция. React добавляет ее в очередь.
*/

/* Когда вы вызываете useState во время следующего рендеринга, React просматривает очередь. Предыдущее состояние number было 0, поэтому именно его React передает первой функции обновления в качестве аргумента n. Затем React берет возвращаемое значение предыдущей функции обновления и передает его следующей функции обновления как n, и так далее:

queued update	  n	    returns
n => n + 1      0     0 + 1 = 1
n => n + 1      1     1 + 1 = 2
n => n + 1      2     2 + 1 = 3
*/

// React сохраняет 3 как конечный результат и возвращает его из useState.

// Вот почему нажатие на "+3" в примере выше правильно увеличивает значение на 3.

//# Что произойдет, если вы обновите состояние после его замены
// Как насчет этого обработчика событий? Как вы думаете, каким будет number в следующем рендере?

<button
  onClick={() => {
    setNumber(number + 5);
    setNumber(n => n + 1);
  }}
/>;

//* App.js
import { useState } from 'react';

function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 5);
          setNumber(n => n + 1);
        }}
      >
        Increase the number
      </button>
    </>
  );
}

/* Вот что этот обработчик событий говорит React сделать:
1. setNumber(number + 5): number - это 0, поэтому setNumber(0 + 5). React добавляет "заменить на 5" в свою очередь.
2. setNumber(n => n + 1): n => n + 1 - это функция обновления. React добавляет эту функцию в свою очередь.
*/

