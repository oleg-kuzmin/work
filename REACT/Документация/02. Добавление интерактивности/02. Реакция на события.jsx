//# Реакция на события
// React позволяет добавлять обработчики событий в JSX. Обработчики событий - это ваши собственные функции, которые будут запускаться в ответ на такие взаимодействия, как нажатие, наведение курсора, фокусировка ввода формы и так далее.

/* Вы узнаете
- Различные способы написания обработчика событий
- Как передать логику обработки событий от родительского компонента
- Как распространяются события и как их остановить
*/

//# Добавление обработчиков событий
// Чтобы добавить обработчик событий, вы сначала определите функцию, а затем передадите ее как параметр в соответствующий JSX тег. Например, вот кнопка, которая еще ничего не делает:

//* App.js
function Button() {
  return <button>I don't do anything</button>;
}

/* Вы можете заставить его показывать сообщение, когда пользователь нажимает на кнопку, выполнив следующие три шага:
1. Объявите функцию handleClick внутри вашего компонента Button.
2. Реализуйте логику внутри этой функции (используйте alert для показа сообщения).
3. Добавьте onClick={handleClick} в JSX <button>.
*/

//* App.js
function Button() {
  function handleClick() {
    alert('You clicked me!');
  }
  return <button onClick={handleClick}>Click me</button>;
}

/* Вы определили функцию handleClick, а затем передали ее как параметр в <button>. handleClick - это обработчик события. Функции обработчика события:
- Обычно определяются внутри ваших компонентов.
- Имеют имена, начинающиеся с handle, за которым следует имя события.
*/

// По традиции, принято называть обработчики событий handle, за которым следует имя события. Часто можно встретить onClick={handleClick}, onMouseEnter={handleMouseEnter} и так далее.

// В качестве альтернативы вы можете определить обработчик события в JSX:

<button
  onClick={function handleClick() {
    alert('You clicked me!');
  }}
/>;

// Или, более кратко, с помощью стрелочной функции:

<button
  onClick={() => {
    alert('You clicked me!');
  }}
/>;

// Все эти стили эквивалентны. Инлайн-обработчики событий удобны для коротких функций.

//! Внимание
/* Функции, передаваемые в обработчики событий, должны передаваться, а не вызываться. Например:
передача функции (правильно)              вызов функции (неправильно)
<button onClick={handleClick}>            <button onClick={handleClick()}></button>
*/

// Разница очень тонкая. В первом примере функция handleClick передается как обработчик события onClick. Это говорит React запомнить ее и вызывать вашу функцию только тогда, когда пользователь нажмет на кнопку.

// Во втором примере () в конце handleClick() запускает функцию непосредственно во время rendering, без каких-либо кликов. Это происходит потому, что JavaScript внутри JSX { и } выполняется сразу же.

/* Когда вы пишете код inline, тот же самый подводный камень проявляется по-другому:
передача функции (правильно)              вызов функции (неправильно)
<button onClick={() => alert('...')}>     <button onClick={alert('...')}></button>
*/

// Передача встроенного кода таким образом не срабатывает по щелчку - он срабатывает каждый раз, когда компонент отображается:
<button onClick={alert('You clicked me!')} />;

// Если вы хотите определить обработчик события в строке, оберните его в анонимную функцию, как показано ниже:
<button onClick={() => alert('You clicked me!')} />;

// Вместо того чтобы выполнять внутренний код при каждом рендере, создается функция, которая будет вызвана позже.

/* В обоих случаях вы хотите передать функцию:
- <button onClick={handleClick}> передает функцию handleClick.
- <button onClick={() => alert('...')}> передает функцию () => alert('...').
*/
//! Внимание

//# Чтение пропсов в обработчиках событий
// Поскольку обработчики событий объявлены внутри компонента, они имеют доступ к пропсам компонента. Вот кнопка, которая при нажатии показывает оповещение со своим пропсом message:

//* App.js
function AlertButton({ message, children }) {
  return <button onClick={() => alert(message)}>{children}</button>;
}

function Toolbar() {
  return (
    <div>
      <AlertButton message="Playing!">Play Movie</AlertButton>
      <AlertButton message="Uploading!">Upload Image</AlertButton>
    </div>
  );
}

// Это позволяет этим двум кнопкам показывать разные сообщения. Попробуйте изменить передаваемые им сообщения.

//# Передача обработчиков событий как пропсов
// Часто требуется, чтобы родительский компонент указывал обработчик событий дочернего компонента. Рассмотрим кнопки: в зависимости от того, где вы используете компонент Button, вы можете захотеть выполнить разные функции - возможно, одна воспроизводит фильм, а другая загружает изображение.

// Для этого в качестве обработчика события передайте пропс, который компонент получает от своего родителя, следующим образом:

//* App.js
function Button({ onClick, children }) {
  return <button onClick={onClick}>{children}</button>;
}

function PlayButton({ movieName }) {
  function handlePlayClick() {
    alert(`Playing ${movieName}!`);
  }

  return <Button onClick={handlePlayClick}>Play "{movieName}"</Button>;
}

function UploadButton() {
  return <Button onClick={() => alert('Uploading!')}>Upload Image</Button>;
}

function Toolbar() {
  return (
    <div>
      <PlayButton movieName="Kiki's Delivery Service" />
      <UploadButton />
    </div>
  );
}

/* Здесь компонент Toolbar отображает PlayButton и UploadButton:
- PlayButton передает handlePlayClick как свойство onClick для Button внутри.
- UploadButton передает () => alert('Uploading!') как свойство onClick внутренней кнопке.
*/

// Наконец, ваш компонент Button принимает свойство onClick. Он передает это свойство непосредственно встроенному браузеру <button> с onClick={onClick}. Это указывает React на вызов переданной функции по щелчку.

// Если вы используете систему дизайна, то обычно такие компоненты, как кнопки, содержат стиль, но не определяют поведение. Вместо этого такие компоненты, как PlayButton и UploadButton, передают обработчики событий вниз.

//# Именование параметров обработчика событий
