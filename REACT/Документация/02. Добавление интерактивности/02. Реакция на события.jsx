//# Реакция на события
// React позволяет добавлять обработчики событий в JSX. Обработчики событий - это ваши собственные функции, которые будут запускаться в ответ на такие взаимодействия, как нажатие, наведение курсора, фокусировка ввода формы и так далее.

/* Вы узнаете
- Различные способы написания обработчика событий
- Как передать логику обработки событий от родительского компонента
- Как распространяются события и как их остановить
*/

//# Добавление обработчиков событий
// Чтобы добавить обработчик событий, вы сначала определите функцию, а затем передадите ее как параметр в соответствующий JSX тег. Например, вот кнопка, которая еще ничего не делает:

//* App.js
function Button() {
  return <button>I don't do anything</button>;
}

/* Вы можете заставить его показывать сообщение, когда пользователь нажимает на кнопку, выполнив следующие три шага:
1. Объявите функцию handleClick внутри вашего компонента Button.
2. Реализуйте логику внутри этой функции (используйте alert для показа сообщения).
3. Добавьте onClick={handleClick} в JSX <button>.
*/

//* App.js
function Button() {
  function handleClick() {
    alert('You clicked me!');
  }
  return <button onClick={handleClick}>Click me</button>;
}

/* Вы определили функцию handleClick, а затем передали ее как параметр в <button>. handleClick - это обработчик события. Функции обработчика события:
- Обычно определяются внутри ваших компонентов.
- Имеют имена, начинающиеся с handle, за которым следует имя события.
*/

// По традиции, принято называть обработчики событий handle, за которым следует имя события. Часто можно встретить onClick={handleClick}, onMouseEnter={handleMouseEnter} и так далее.

// В качестве альтернативы вы можете определить обработчик события в JSX:

<button
  onClick={function handleClick() {
    alert('You clicked me!');
  }}
/>;

// Или, более кратко, с помощью стрелочной функции:

<button
  onClick={() => {
    alert('You clicked me!');
  }}
/>;

// Все эти стили эквивалентны. Инлайн-обработчики событий удобны для коротких функций.

//! Внимание
/* Функции, передаваемые в обработчики событий, должны передаваться, а не вызываться. Например:
передача функции (правильно)              вызов функции (неправильно)
<button onClick={handleClick}>            <button onClick={handleClick()}></button>
*/

// Разница очень тонкая. В первом примере функция handleClick передается как обработчик события onClick. Это говорит React запомнить ее и вызывать вашу функцию только тогда, когда пользователь нажмет на кнопку.

// Во втором примере () в конце handleClick() запускает функцию непосредственно во время rendering, без каких-либо кликов. Это происходит потому, что JavaScript внутри JSX { и } выполняется сразу же.

/* Когда вы пишете код inline, тот же самый подводный камень проявляется по-другому:
передача функции (правильно)              вызов функции (неправильно)
<button onClick={() => alert('...')}>     <button onClick={alert('...')}></button>
*/

// Передача встроенного кода таким образом не срабатывает по щелчку - он срабатывает каждый раз, когда компонент отображается:
<button onClick={alert('You clicked me!')} />;

// Если вы хотите определить обработчик события в строке, оберните его в анонимную функцию, как показано ниже:
<button onClick={() => alert('You clicked me!')} />;

// Вместо того чтобы выполнять внутренний код при каждом рендере, создается функция, которая будет вызвана позже.

/* В обоих случаях вы хотите передать функцию:
- <button onClick={handleClick}> передает функцию handleClick.
- <button onClick={() => alert('...')}> передает функцию () => alert('...').
*/
//! Внимание

//# Чтение пропсов в обработчиках событий
// Поскольку обработчики событий объявлены внутри компонента, они имеют доступ к пропсам компонента. Вот кнопка, которая при нажатии показывает оповещение со своим пропсом message:

//* App.js
function AlertButton({ message, children }) {
  return <button onClick={() => alert(message)}>{children}</button>;
}

function Toolbar() {
  return (
    <div>
      <AlertButton message="Playing!">Play Movie</AlertButton>
      <AlertButton message="Uploading!">Upload Image</AlertButton>
    </div>
  );
}

// Это позволяет этим двум кнопкам показывать разные сообщения. Попробуйте изменить передаваемые им сообщения.

//# Передача обработчиков событий как пропсов
// Часто требуется, чтобы родительский компонент указывал обработчик событий дочернего компонента. Рассмотрим кнопки: в зависимости от того, где вы используете компонент Button, вы можете захотеть выполнить разные функции - возможно, одна воспроизводит фильм, а другая загружает изображение.

// Для этого в качестве обработчика события передайте пропс, который компонент получает от своего родителя, следующим образом:

//* App.js
function Button({ onClick, children }) {
  return <button onClick={onClick}>{children}</button>;
}

function PlayButton({ movieName }) {
  function handlePlayClick() {
    alert(`Playing ${movieName}!`);
  }

  return <Button onClick={handlePlayClick}>Play "{movieName}"</Button>;
}

function UploadButton() {
  return <Button onClick={() => alert('Uploading!')}>Upload Image</Button>;
}

function Toolbar() {
  return (
    <div>
      <PlayButton movieName="Kiki's Delivery Service" />
      <UploadButton />
    </div>
  );
}

/* Здесь компонент Toolbar отображает PlayButton и UploadButton:
- PlayButton передает handlePlayClick как свойство onClick для Button внутри.
- UploadButton передает () => alert('Uploading!') как свойство onClick внутренней кнопке.
*/

// Наконец, ваш компонент Button принимает свойство onClick. Он передает это свойство непосредственно встроенному браузеру <button> с onClick={onClick}. Это указывает React на вызов переданной функции по щелчку.

// Если вы используете систему дизайна, то обычно такие компоненты, как кнопки, содержат стиль, но не определяют поведение. Вместо этого такие компоненты, как PlayButton и UploadButton, передают обработчики событий вниз.

//# Именование параметров обработчика событий
// Встроенные компоненты, такие как <button> и <div>, поддерживают только имена событий браузера, такие как onClick. Однако, когда вы создаете свои собственные компоненты, вы можете называть их пропсы обработчиков событий как угодно.

// По соглашению, пропсы обработчиков событий должны начинаться с on, за которым следует заглавная буква.

// Например, пропс onClick компонента Button можно было бы назвать onSmash:

//* App.js
function Button({ onSmash, children }) {
  return <button onClick={onSmash}>{children}</button>;
}

function App() {
  return (
    <div>
      <Button onSmash={() => alert('Playing!')}>Play Movie</Button>
      <Button onSmash={() => alert('Uploading!')}>Upload Image</Button>
    </div>
  );
}

// В этом примере <button onClick={onSmash}> показывает, что браузеру <button> (строчная буква) по-прежнему нужен пропс onClick, но имя пропса, полученное вашим пользовательским компонентом Button, зависит от вас!

// Если ваш компонент поддерживает множество взаимодействий, вы можете назвать пропсы обработчиков событий для концепций, специфичных для конкретного приложения. Например, компонент Toolbar получает обработчики событий onPlayMovie и onUploadImage:

//* App.js
function App() {
  return <Toolbar onPlayMovie={() => alert('Playing!')} onUploadImage={() => alert('Uploading!')} />;
}

function Toolbar({ onPlayMovie, onUploadImage }) {
  return (
    <div>
      <Button onClick={onPlayMovie}>Play Movie</Button>
      <Button onClick={onUploadImage}>Upload Image</Button>
    </div>
  );
}

function Button({ onClick, children }) {
  return <button onClick={onClick}>{children}</button>;
}

// Обратите внимание, что компоненту App не нужно знать, что Toolbar будет делать с onPlayMovie или onUploadImage. Это деталь реализации Toolbar. Здесь Toolbar передает их как обработчики onClick для своих Button, но позже он также может вызвать их по нажатию клавиш. Именование пропсов в честь специфических для приложения взаимодействий, таких как onPlayMovie, дает вам возможность гибко изменять их использование в дальнейшем.

//* Примечание
// Убедитесь, что вы используете соответствующие HTML-теги для обработчиков событий. Например, для обработки кликов используйте <button onClick={handleClick}> вместо <div onClick={handleClick}>. Использование настоящего браузерного <button> позволяет использовать встроенные поведенческие характеристики браузера, такие как навигация по клавиатуре. Если вам не нравится стандартная стилизация кнопки в браузере и вы хотите сделать ее более похожей на ссылку или другой элемент пользовательского интерфейса, вы можете добиться этого с помощью CSS. Узнайте больше о написании доступной разметки.
//* Примечание

//# Распространение событий
// Обработчики событий также будут улавливать события от всех дочерних компонентов, которые могут быть у вашего компонента. Мы говорим, что событие "бурлит" или "распространяется" вверх по дереву: оно начинается с того места, где произошло событие, а затем поднимается вверх по дереву.

// Этот <div> содержит две кнопки. И <div> и каждая кнопка имеют свои собственные обработчики onClick. Как вы думаете, какие обработчики сработают при нажатии на кнопку?

//* App.js
function Toolbar() {
  return (
    <div
      className="Toolbar"
      onClick={() => {
        alert('You clicked on the toolbar!');
      }}
    >
      <button onClick={() => alert('Playing!')}>Play Movie</button>
      <button onClick={() => alert('Uploading!')}>Upload Image</button>
    </div>
  );
}

// Если вы нажмете на любую из кнопок, сначала сработает ее onClick, а затем onClick родительской <div>. Таким образом, появятся два сообщения. Если щелкнуть на самой панели инструментов, то будет запущена только onClick родительской <div>.

//! Внимание
// Все события распространяются в React, кроме onScroll, которое действует только на тег JSX, к которому вы его прикрепили.
//! Внимание

//# Остановка распространения
// Обработчики событий получают объект event в качестве единственного аргумента. По традиции он обычно называется e, что означает "событие". Вы можете использовать этот объект для чтения информации о событии.

// Этот объект события также позволяет остановить распространение. Если вы хотите, чтобы событие не достигло родительских компонентов, вам нужно вызвать e.stopPropagation(), как это делает компонент Button:

//* App.js
function Button({ onClick, children }) {
  return (
    <button
      onClick={e => {
        e.stopPropagation();
        onClick();
      }}
    >
      {children}
    </button>
  );
}

function Toolbar() {
  return (
    <div
      className="Toolbar"
      onClick={() => {
        alert('You clicked on the toolbar!');
      }}
    >
      <Button onClick={() => alert('Playing!')}>Play Movie</Button>
      <Button onClick={() => alert('Uploading!')}>Upload Image</Button>
    </div>
  );
}

/* Когда вы нажимаете на кнопку:
1. React вызывает обработчик onClick, переданный в <button>.
2. Этот обработчик, определенный в Button, делает следующее:
  - Вызывает e.stopPropagation(), предотвращая дальнейшее распространение события.
  - Вызывает функцию onClick, которая является пропсом, переданным из компонента Toolbar.
3. Эта функция, определенная в компоненте Toolbar, отображает собственное оповещение кнопки.
4. Поскольку распространение было остановлено, обработчик onClick родительского <div> не выполняется.
*/

// В результате e.stopPropagation(), при нажатии на кнопки теперь отображается только одно оповещение (из <button>), а не оба (из <button> и родительской панели инструментов <div>). Нажатие на кнопку - это не то же самое, что нажатие на окружающую панель инструментов, поэтому остановка распространения имеет смысл для данного пользовательского интерфейса.

//* Захват фазовых событий
// В редких случаях вам может понадобиться перехватить все события на дочерних элементах, даже если они прекратили распространение. Например, вы хотите регистрировать каждый клик в аналитике, независимо от логики распространения. Вы можете сделать это, добавив Capture в конце имени события:

<div
  onClickCapture={() => {
    /* this runs first */
  }}
>
  <button onClick={e => e.stopPropagation()} />
  <button onClick={e => e.stopPropagation()} />
</div>;

/* Каждое событие распространяется в три фазы:
1. Оно перемещается вниз, вызывая все обработчики onClickCapture.
2. Запускается обработчик onClick щелкнутого элемента.
3. Он перемещается вверх, вызывая все обработчики onClick.
*/

// События захвата полезны для такого кода, как маршрутизаторы или аналитика, но вы, вероятно, не будете использовать их в коде приложений.
//* Захват фазовых событий

//# Передача обработчиков как альтернатива распространению
// Обратите внимание, как этот обработчик кликов выполняет строку кода и затем вызывает onClick, переданный родителем:

function Button({ onClick, children }) {
  return (
    <button
      onClick={e => {
        e.stopPropagation();
        onClick();
      }}
    >
      {children}
    </button>
  );
}

// Вы можете добавить больше кода в этот обработчик перед вызовом обработчика родительского события onClick. Этот паттерн обеспечивает альтернативу распространению. Он позволяет дочернему компоненту обрабатывать событие, в то же время позволяя родительскому компоненту задать дополнительное поведение. В отличие от распространения, он не является автоматическим. Но преимущество этого паттерна в том, что вы можете четко проследить всю цепочку кода, который выполняется в результате какого-то события.

// Если вы полагаетесь на распространение и вам сложно отследить, какие обработчики выполняются и почему, попробуйте применить этот подход.

//# Предотвращение поведения по умолчанию
// Некоторые события браузера имеют поведение по умолчанию, связанное с ними. Например, событие отправки <form>, которое происходит при нажатии на кнопку внутри него, по умолчанию перезагружает всю страницу:

//* App.js
function Signup() {
  return (
    <form onSubmit={() => alert('Submitting!')}>
      <input />
      <button>Send</button>
    </form>
  );
}

// Чтобы этого не произошло, можно вызвать e.preventDefault() на объекте события:

//* App.js
function Signup() {
  return (
    <form
      onSubmit={e => {
        e.preventDefault();
        alert('Submitting!');
      }}
    >
      <input />
      <button>Send</button>
    </form>
  );
}

/* Не путайте e.stopPropagation() и e.preventDefault(). Они оба полезны, но не связаны между собой:
- e.stopPropagation() останавливает срабатывание обработчиков событий, прикрепленных к вышеуказанным тегам.
- e.preventDefault() предотвращает поведение браузера по умолчанию для тех немногих событий, в которых он есть.
*/

//# Могут ли обработчики событий иметь побочные эффекты?

