//# Состояние как моментальный снимок
// Переменные состояния могут выглядеть как обычные переменные JavaScript, которые можно читать и записывать. Однако состояние ведет себя скорее как моментальный снимок. Установка состояния не изменяет уже имеющуюся переменную состояния, а вместо этого вызывает повторный рендеринг.

/* Вы узнаете
- Как установка состояния вызывает повторный рендеринг
- Когда и как обновляется состояние
- Почему состояние не обновляется сразу после его установки
- Как обработчики событий получают доступ к "снимку" состояния
*/

//# Установка состояния запускает рендеринг
// Вы можете думать о том, что ваш пользовательский интерфейс меняется непосредственно в ответ на событие пользователя, например, на клик. В React эта мысленная модель работает несколько иначе. На предыдущей странице вы видели, что установка состояния запрашивает повторный рендеринг в React. Это означает, что для того, чтобы интерфейс отреагировал на событие, необходимо обновить состояние.

// В этом примере, когда вы нажимаете кнопку "отправить", setIsSent(true) сообщает React о необходимости повторного рендеринга пользовательского интерфейса:

//* App.js
import { useState } from 'react';

function Form() {
  const [isSent, setIsSent] = useState(false);
  const [message, setMessage] = useState('Hi!');
  if (isSent) {
    return <h1>Your message is on its way!</h1>;
  }
  return (
    <form
      onSubmit={e => {
        e.preventDefault();
        setIsSent(true);
        sendMessage(message);
      }}
    >
      <textarea placeholder="Message" value={message} onChange={e => setMessage(e.target.value)} />
      <button type="submit">Send</button>
    </form>
  );
}

function sendMessage(message) {
  // ...
}

/* Вот что происходит, когда вы нажимаете на кнопку:
1. Выполняется обработчик события onSubmit.
2. setIsSent(true) устанавливает isSent в true и ставит в очередь новый рендер.
3. React повторно рендерит компонент в соответствии с новым значением isSent.
*/

// Давайте подробнее рассмотрим связь между состоянием и рендерингом.

//# Рендеринг делает моментальный снимок времени
// "Rendering" означает, что React вызывает ваш компонент, который является функцией. JSX, который вы возвращаете из этой функции, — это как снимок пользовательского интерфейса во времени. Его пропсы, обработчики событий и локальные переменные были рассчитаны используя его состояние на момент рендеринга.

// В отличие от фотографии или кадра фильма, возвращаемый вами "снимок" пользовательского интерфейса является интерактивным. Он включает в себя логику, например, обработчики событий, которые определяют, что происходит в ответ на входные данные. React обновляет экран в соответствии с этим снимком и подключает обработчики событий. В результате нажатие кнопки вызовет обработчик нажатия из вашего JSX.

/* Когда React перерисовывает компонент:
1. React снова вызывает вашу функцию.
2. Ваша функция возвращает новый снимок JSX.
3. Затем React обновляет экран в соответствии с полученным снимком.
*/

// Как память компонента, state не похож на обычную переменную, которая исчезает после возвращения вашей функции. Состояние фактически "живет" в самом React - как будто на полке!- вне вашей функции. Когда React вызывает ваш компонент, он дает вам снимок состояния для этого конкретного рендера. Ваш компонент возвращает снимок пользовательского интерфейса со свежим набором пропсов и обработчиков событий в своем JSX, все рассчитано используя значения состояния из этого рендера!

/*
- Вы говорите React обновить состояние
- React обновляет значение состояния
- React передает снимок значения состояния в компонент
*/

// Вот небольшой эксперимент, чтобы показать вам, как это работает. В этом примере вы можете ожидать, что нажатие кнопки "+3" увеличит счетчик в три раза, потому что он вызывает setNumber(number + 1) три раза.

// Посмотрите, что произойдет, когда вы нажмете кнопку "+3":

//* App.js
import { useState } from 'react';

function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 1);
          setNumber(number + 1);
          setNumber(number + 1);
        }}
      >
        +3
      </button>
    </>
  );
}

// Обратите внимание, что number увеличивается только один раз за клик!

// Установка состояния изменяет его только для следующего рендера. Во время первого рендера number было 0. Вот почему в обработчике onClick того рендера значение number все еще 0, даже после вызова setNumber(number + 1):

<button
  onClick={() => {
    setNumber(number + 1);
    setNumber(number + 1);
    setNumber(number + 1);
  }}
>
  +3
</button>;

/* Вот что обработчик нажатия этой кнопки говорит React сделать:
1. setNumber(number + 1): number - это 0, поэтому setNumber(0 + 1)
- React готовится изменить число на 1 при следующем рендере.

2. setNumber(number + 1): number - 0, поэтому setNumber(0 + 1)
- React готовится изменить number на 1 при следующем рендере.

3. setNumber(number + 1): number - 0, поэтому setNumber(0 + 1)
- React готовится изменить number на 1 при следующем рендере.
*/

// Несмотря на то, что вы вызвали setNumber(number + 1) три раза, в обработчике событий этого рендера number всегда 0, поэтому вы установили состояние 1 три раза. Вот почему после завершения обработчика событий React повторно рендерит компонент с number, равным 1, а не 3.

// Вы также можете представить себе это, мысленно заменив переменные состояния их значениями в коде. Поскольку переменная состояния number равна 0 для этого рендера, его обработчик событий выглядит следующим образом:

<button
  onClick={() => {
    setNumber(0 + 1);
    setNumber(0 + 1);
    setNumber(0 + 1);
  }}
>
  +3
</button>;

// Для следующего рендера number будет 1, поэтому обработчик клика этого рендера будет выглядеть следующим образом:

<button
  onClick={() => {
    setNumber(1 + 1);
    setNumber(1 + 1);
    setNumber(1 + 1);
  }}
>
  +3
</button>;

// Вот почему повторное нажатие на кнопку установит счетчик на 2, затем на 3 при следующем нажатии и т. д.

//# Состояние с течением времени
// Что ж, это было забавно. Попробуйте угадать, о чем предупредит нажатие на эту кнопку:

//* App.js
import { useState } from 'react';

function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 5);
          alert(number);
        }}
      >
        +5
      </button>
    </>
  );
}


