//# Условный рендеринг
// Вашим компонентам часто придется отображать разные вещи в зависимости от разных условий. В React вы можете условно визуализировать JSX, используя синтаксис JavaScript if, такой как оператор или "&&" и тернарный оператор "?:".

/* Ты выучишь:
- Как вернуть разные JSX в зависимости от условия
- Как условно включить или исключить часть JSX
- Распространенные сочетания клавиш условного синтаксиса, которые вы встретите в кодовых базах React
*/

//# Условный возврат JSX
// Допустим, у вас есть компонент PackingList, отображающий несколько объектов Item, которые можно пометить как упакованные или нет:

function Item({ name, isPacked }) {
  return <li className="item">{name}</li>;
}

function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item isPacked={true} name="Space suit" />
        <Item isPacked={true} name="Helmet with a golden leaf" />
        <Item isPacked={false} name="Photo of Tam" />
      </ul>
    </section>
  );
}

// Обратите внимание, что для некоторых компонентов Item установлено значение isPacked = true вместо false. Вы хотите добавить галочку (✔) к упакованным товарам, если isPacked={true}.

// Вы можете написать это как оператор if/else вот так:

function Item({ name, isPacked }) {
  if (isPacked) {
    return <li className="item">{name} ✔</li>;
  }
  return <li className="item">{name}</li>;
}

// Если свойство isPacked имеет значение true, этот код возвращает другое дерево JSX. Благодаря этому изменению некоторые элементы получают галочку в конце:

function Item({ name, isPacked }) {
  if (isPacked) {
    return <li className="item">{name} ✔</li>;
  }
  return <li className="item">{name}</li>;
}

function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item isPacked={true} name="Space suit" />
        <Item isPacked={true} name="Helmet with a golden leaf" />
        <Item isPacked={false} name="Photo of Tam" />
      </ul>
    </section>
  );
}

// Попробуйте отредактировать то, что возвращается в любом случае, и посмотрите, как изменится результат!

// Обратите внимание, как вы создаете логику ветвления с помощью операторов if и return JavaScript. В React поток управления (например, условия) обрабатывается JavaScript.

//# Условно возвращающийся null
// В некоторых ситуациях вам вообще не захочется ничего рендерить. Например, предположим, что вы вообще не хотите показывать упакованные предметы. Компонент должен что-то возвращать. В этом случае вы можете вернуть null:

function Item({ name, isPacked }) {
  if (isPacked) {
    return null;
  }
  return <li className="item">{name}</li>;
}

// Если isPacked имеет значение true, компонент ничего не вернет, null. В противном случае он вернет JSX для рендеринга.

function Item({ name, isPacked }) {
  if (isPacked) {
    return null;
  }
  return <li className="item">{name}</li>;
}

function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item isPacked={true} name="Space suit" />
        <Item isPacked={true} name="Helmet with a golden leaf" />
        <Item isPacked={false} name="Photo of Tam" />
      </ul>
    </section>
  );
}

// На практике возврат значения null из компонента встречается нечасто, поскольку это может удивить разработчика, пытающегося его отобразить. Чаще всего вы условно включаете или исключаете компонент из JSX родительского компонента. Вот как это сделать!

//# Условно включаемый JSX
// В предыдущем примере вы контролировали, какое дерево JSX (если оно есть!) будет возвращено компонентом. Возможно, вы уже заметили некоторое дублирование в выводе рендеринга:

<li className="item">{name} ✔</li>;

// очень похоже на

<li className="item">{name}</li>;

// Обе условные ветки возвращают <li className="item">...</li>:

function Item({ name, isPacked }) {
  if (isPacked) {
    return <li className="item">{name} ✔</li>;
  }
  return <li className="item">{name}</li>;
}

// Хотя такое дублирование не является вредным, оно может усложнить поддержку вашего кода. Что делать, если вы хотите изменить className? Вам придется сделать это в двух местах вашего кода! В такой ситуации вы можете условно включить немного JSX, чтобы сделать ваш код более правильным (DRY).

//# Условный (тернарный) оператор (?:)
// В JavaScript имеется компактный синтаксис для написания условного выражения — условный оператор или «тернарный оператор».

// Вместо этого:

function Item({ name, isPacked }) {
  if (isPacked) {
    return <li className="item">{name} ✔</li>;
  }
  return <li className="item">{name}</li>;
}

// Вы можете написать это:

function Item({ name, isPacked }) {
  return <li className="item">{isPacked ? name + ' ✔' : name}</li>;
}

// Вы можете прочитать это так: если isPacked истинно, то (?) имя рендеринга + ' ✔', иначе (:) имя рендеринга.

//* ГЛУБОКОЕ ПОГРУЖЕНИЕ (Являются ли эти два примера полностью эквивалентными?)
// Если вы имеете опыт объектно-ориентированного программирования, вы можете предположить, что два приведенных выше примера немного отличаются, поскольку один из них может создавать два разных «экземпляра» <li>. Но элементы JSX не являются «экземплярами», поскольку они не хранят никакого внутреннего состояния и не являются настоящими узлами DOM. Это легкие описания, вроде чертежей. Так что эти два примера, по сути, полностью эквивалентны. В разделе «Preserving and Resetting State» подробно описано, как это работает.
//* ГЛУБОКОЕ ПОГРУЖЕНИЕ (Являются ли эти два примера полностью эквивалентными?)

// Теперь предположим, что вы хотите поместить текст завершенного элемента в другой HTML-тег, например <del>, чтобы вычеркнуть его. Вы можете добавить еще больше символов новой строки и круглых скобок, чтобы в каждом из случаев было проще вкладывать больше JSX:

function Item({ name, isPacked }) {
  return <li className="item">{isPacked ? <del>{name + ' ✔'}</del> : name}</li>;
}

function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item isPacked={true} name="Space suit" />
        <Item isPacked={true} name="Helmet with a golden leaf" />
        <Item isPacked={false} name="Photo of Tam" />
      </ul>
    </section>
  );
}

// Этот стиль хорошо работает для простых условий, но используйте его в умеренных количествах. Если ваши компоненты запутались из-за слишком большого количества вложенной условной разметки, рассмотрите возможность извлечения дочерних компонентов, чтобы навести порядок.

//# Логический оператор И (&&)
// Еще один распространенный шорткат, с которым вы столкнетесь, — это логический оператор AND (&&) в JavaScript. Внутри компонентов React это часто возникает, когда вы хотите отобразить некоторый JSX, когда условие истинно, или ничего не визуализировать в противном случае. С помощью && вы можете условно отобразить галочку, только если isPacked имеет значение true:

function Item({ name, isPacked }) {
  return (
    <li className="item">
      {name} {isPacked && '✔'}
    </li>
  );
}

// Вы можете прочитать это так: если isPacked, то (&&) отображает галочку, в противном случае ничего не отображает.

// Вот оно в действии:

function Item({ name, isPacked }) {
  return (
    <li className="item">
      {name} {isPacked && '✔'}
    </li>
  );
}

function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item isPacked={true} name="Space suit" />
        <Item isPacked={true} name="Helmet with a golden leaf" />
        <Item isPacked={false} name="Photo of Tam" />
      </ul>
    </section>
  );
}

// Выражение && в JavaScript возвращает значение своей правой части (в нашем случае галочки), если левая часть (наше условие) истинна. Но если условие ложно, все выражение становится ложным. React рассматривает false как «дыру» в дереве JSX, точно так же, как null или undefine, и ничего не отображает на ее месте.

//! Ловушка
// Не ставьте цифры слева от &&.

// Чтобы проверить условие, JavaScript автоматически преобразует левую часть в логическое значение. Однако если левая часть равна 0, то все выражение получит это значение (0), и React с радостью отобразит 0, а не ничего.

// Например, распространенной ошибкой является написание кода типа messageCount && <p>Новые сообщения</p>. Легко предположить, что он ничего не отображает, когда messageCount равен 0, но на самом деле он отображает сам 0!

// Чтобы это исправить, сделайте левую часть логической: messageCount > 0 && <p>Новые сообщения</p>.
//! Ловушка

//# Условное присвоение JSX переменной
// Если шорткаты мешают писать простой код, попробуйте использовать оператор if и переменную. Вы можете переназначать переменные, определенные с помощью let, поэтому начните с предоставления содержимого по умолчанию, которое вы хотите отобразить, а именно имени:

let itemContent = name;

// Используйте оператор if, чтобы переназначить выражение JSX для itemContent, если isPacked имеет значение true:

if (isPacked) {
  itemContent = name + ' ✔';
}

// Фигурные скобки открывают «окно в JavaScript». Вставьте переменную с фигурными скобками в возвращаемое дерево JSX, вложив ранее вычисленное выражение внутрь JSX:

<li className="item">{itemContent}</li>;

// Этот стиль является самым многословным, но и самым гибким. Вот оно в действии:

function Item({ name, isPacked }) {
  let itemContent = name;
  if (isPacked) {
    itemContent = name + ' ✔';
  }
  return <li className="item">{itemContent}</li>;
}

function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item isPacked={true} name="Space suit" />
        <Item isPacked={true} name="Helmet with a golden leaf" />
        <Item isPacked={false} name="Photo of Tam" />
      </ul>
    </section>
  );
}

// Как и раньше, это работает не только для текста, но и для произвольного JSX:

function Item({ name, isPacked }) {
  let itemContent = name;
  if (isPacked) {
    itemContent = <del>{name + ' ✔'}</del>;
  }
  return <li className="item">{itemContent}</li>;
}

// Если вы не знакомы с JavaScript, такое разнообразие стилей на первый взгляд может показаться ошеломляющим. Однако их изучение поможет вам читать и писать любой код JavaScript, а не только компоненты React! Для начала выберите тот, который вам больше нравится, а затем снова обратитесь к этому справочнику, если вы забыли, как работают другие.

//# Резюме
/*
- В React вы управляете логикой ветвления с помощью JavaScript.
- Вы можете вернуть выражение JSX условно с помощью оператора if.
- Вы можете условно сохранить некоторый JSX в переменную, а затем включить его в другой JSX, используя фигурные скобки.
- В JSX {cond ? <A/>: <B/>} означает «если cond, визуализировать <A/>, иначе <B/>».
- В JSX {cond && <A />} означает «если cond, отображать <A />, иначе ничего».
- Шорткаты являются общими, но вам не обязательно их использовать, если вы предпочитаете простой if.
*/
