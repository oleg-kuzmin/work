//# Рендеринг списков
// Часто вам потребуется отобразить несколько похожих компонентов из коллекции данных. Вы можете использовать методы массива JavaScript для управления массивом данных. На этой странице вы будете использовать filter() и map() с React для фильтрации и преобразования массива данных в массив компонентов.

/*
Ты выучишь
- Как визуализировать компоненты из массива с помощью метода map JavaScript ()
- Как визуализировать только определенные компоненты, используя метод filter JavaScript()
- Когда и зачем использовать ключи React
*/

//# Рендеринг данных из массивов
// Допустим, у вас есть список контента.

<ul>
  <li>Creola Katherine Johnson: mathematician</li>
  <li>Mario José Molina-Pasquel Henríquez: chemist</li>
  <li>Mohammad Abdus Salam: physicist</li>
  <li>Percy Lavon Julian: chemist</li>
  <li>Subrahmanyan Chandrasekhar: astrophysicist</li>
</ul>;

// Единственная разница между этими элементами списка — это их содержимое и данные. При построении интерфейсов вам часто придется показывать несколько экземпляров одного и того же компонента, используя разные данные: от списков комментариев до галерей изображений профиля. В таких ситуациях вы можете хранить эти данные в объектах и ​​массивах JavaScript и использовать такие методы, как map() и filter(), для визуализации списков компонентов из них.

// Вот краткий пример того, как создать список элементов из массива:

// 1. Переместите данные в массив:
const people = [
  'Creola Katherine Johnson: mathematician',
  'Mario José Molina-Pasquel Henríquez: chemist',
  'Mohammad Abdus Salam: physicist',
  'Percy Lavon Julian: chemist',
  'Subrahmanyan Chandrasekhar: astrophysicist',
];

function List() {
  // 2. Создайте новый массив узлов JSX, состоящий из членов People, с помощью метода map
  const listItems = people.map(person => <li>{person}</li>);
  // 3. Верните listItems из вашего компонента, завернутого в <ul>:
  return <ul>{listItems}</ul>;
}

// Обратите внимание, что в консоли отображается ошибка:
//! Warning: Each child in a list should have a unique “key” prop.

// Вы узнаете, как исправить эту ошибку позже на этой странице. Прежде чем мы перейдем к этому, давайте добавим некоторую структуру вашим данным.

//# Фильтрация массивов элементов
// Эти данные можно еще более структурировать.

const peopleExpample = [
  {
    id: 0,
    name: 'Creola Katherine Johnson',
    profession: 'mathematician',
  },
  {
    id: 1,
    name: 'Mario José Molina-Pasquel Henríquez',
    profession: 'chemist',
  },
  {
    id: 2,
    name: 'Mohammad Abdus Salam',
    profession: 'physicist',
  },
  {
    name: 'Percy Lavon Julian',
    profession: 'chemist',
  },
  {
    name: 'Subrahmanyan Chandrasekhar',
    profession: 'astrophysicist',
  },
];

// Допустим, вам нужен способ показывать только людей, чья профессия — chemist (химик). Вы можете использовать метод filter() JavaScript, чтобы вернуть только этих людей. Этот метод берет массив элементов, пропускает их через «test» (функцию, которая возвращает true или false) и возвращает новый массив только из тех элементов, которые прошли test (возвращают true).

// Вам нужны только предметы, в которых профессия «химик». Функция «тест» для этого выглядит следующим образом (person) => person.profession === 'chemist'. Вот как это соединить:

//* data.js
const peopleAll = [
  {
    id: 0,
    name: 'Creola Katherine Johnson',
    profession: 'mathematician',
    accomplishment: 'spaceflight calculations',
    imageId: 'MK3eW3A',
  },
  {
    id: 1,
    name: 'Mario José Molina-Pasquel Henríquez',
    profession: 'chemist',
    accomplishment: 'discovery of Arctic ozone hole',
    imageId: 'mynHUSa',
  },
  {
    id: 2,
    name: 'Mohammad Abdus Salam',
    profession: 'physicist',
    accomplishment: 'electromagnetism theory',
    imageId: 'bE7W1ji',
  },
  {
    id: 3,
    name: 'Percy Lavon Julian',
    profession: 'chemist',
    accomplishment: 'pioneering cortisone drugs, steroids and birth control pills',
    imageId: 'IOjWm71',
  },
  {
    id: 4,
    name: 'Subrahmanyan Chandrasekhar',
    profession: 'astrophysicist',
    accomplishment: 'white dwarf star mass calculations',
    imageId: 'lrWQx8l',
  },
];

//* utils.js
function getImageUrl(person) {
  return 'https://i.imgur.com/' + person.imageId + 's.jpg';
}

//* App.js
import { peopleAll } from './data.js';
import { getImageUrl } from './utils.js';

function List() {
  // 1. Создайте новый массив, состоящий только из людей-химиков, вызвав filter() для фильтрации людей по person.profession === 'chemist':
  const chemists = peopleAll.filter(person => person.profession === 'chemist');
  // 2. Теперь создайте новый массив узлов JSX, состоящий из людей-химиков, с помощью метода map:
  const listItems = chemists.map(person => (
    <li>
      <img src={getImageUrl(person)} alt={person.name} />
      <p>
        <b>{person.name}:</b>
        {' ' + person.profession + ' '}
        known for {person.accomplishment}
      </p>
    </li>
  ));
  // 3. Наконец, верните listItems из вашего компонента:
  return <ul>{listItems}</ul>;
}

//! Ловушка
/*
Стрелочные функции неявно возвращают выражение сразу после =>, поэтому оператор return не нужен:
const listItems1 = chemists.map(
  person => <li>...</li>
);

Однако вы должны явно написать return, если за => следует фигурная скобка {!
const listItems2 = chemists.map(person => {
  return <li>...</li>;
});
*/
//! Ловушка

//# Поддержание порядка элементов списка с помощью key
// Обратите внимание на ошибку в консоли:

//! Warning: Each child in a list should have a unique “key” prop.

// Вам необходимо дать каждому элементу массива ключ — строку или число, которое однозначно идентифицирует его среди других элементов этого массива:

<li key={person.id}>...</li>;

//# Примечание
// Элементам JSX непосредственно внутри вызова map() всегда нужны ключи!

// Ключи сообщают React, какому элементу массива соответствует каждый компонент, чтобы он мог сопоставить их позже. Это становится важным, если элементы вашего массива могут перемещаться (например, из-за сортировки), вставляться или удаляться. Правильно выбранный ключ помогает React понять, что именно произошло, и внести правильные обновления в дерево DOM.

// Вместо того, чтобы генерировать ключи на лету, вам следует включить их в свои данные:

//* App.js
import { people } from './data.js';
import { getImageUrl } from './utils.js';

function List() {
  const listItems = people.map(person => (
    <li key={person.id}>
      <img src={getImageUrl(person)} alt={person.name} />
      <p>
        <b>{person.name}</b>
        {' ' + person.profession + ' '}
        known for {person.accomplishment}
      </p>
    </li>
  ));
  return <ul>{listItems}</ul>;
}

//*ГЛУБОКОЕ ПОГРУЖЕНИЕ Отображение нескольких узлов DOM для каждого элемента списка
// Что делать, если каждому элементу необходимо отрисовать не один, а несколько узлов DOM?

// Короткий синтаксис фрагмента <>...</> не позволит вам передать ключ, поэтому вам нужно либо сгруппировать их в один <div>, либо использовать немного более длинный и более явный синтаксис <Fragment>:

import { Fragment } from 'react';
const listItems = people.map(person => (
  <Fragment key={person.id}>
    <h1>{person.name}</h1>
    <p>{person.bio}</p>
  </Fragment>
));

// Фрагменты исчезают из DOM, поэтому создается плоский список <h1>, <p>, <h1>, <p> и т. д.
//*ГЛУБОКОЕ ПОГРУЖЕНИЕ Отображение нескольких узлов DOM для каждого элемента списка

//# Где взять ключ
/*
Различные источники данных предоставляют разные источники ключей:
- Данные из базы данных. Если ваши данные поступают из базы данных, вы можете использовать ключи/идентификаторы базы данных, которые уникальны по своей природе.
- Локально сгенерированные данные: если ваши данные генерируются и сохраняются локально (например, заметки в приложении для заметок), используйте увеличивающийся счетчик, crypto.randomUUID() или такой пакет, как uuid, при создании элементов.
*/

//# Правила ключей
/*
- Ключи должны быть уникальными среди братьев и сестер. Однако можно использовать одни и те же ключи для узлов JSX в разных массивах.
- Ключи не должны меняться, иначе это противоречит их назначению! Не создавайте их во время рендеринга.
*/

//# Зачем React нужны ключи?
// Представьте, что файлы на вашем рабочем столе не имеют имен. Вместо этого вы будете обращаться к ним по порядку — первый файл, второй файл и так далее. К этому можно привыкнуть, но как только вы удалите файл, это приведет к путанице. Второй файл станет первым файлом, третий файл станет вторым файлом и так далее.

// Имена файлов в папке и ключи JSX в массиве служат той же цели. Они позволяют нам однозначно идентифицировать элемент между его братьями и сестрами. Хорошо выбранный ключ предоставляет больше информации, чем позиция в массиве. Даже если позиция изменится из-за изменения порядка, ключ позволяет React идентифицировать элемент на протяжении всего его существования.

//! Ловушка
// У вас может возникнуть соблазн использовать индекс элемента в массиве в качестве его ключа. Фактически, именно это будет использовать React, если вы вообще не укажете ключ. Но порядок, в котором вы отображаете элементы, со временем изменится, если элемент будет вставлен, удален или если массив будет переупорядочен. Индекс как ключ часто приводит к тонким и запутанным ошибкам.

// Аналогично, не генерируйте ключи на лету, например. с ключом = {Math.random()}. Это приведет к тому, что ключи никогда не будут совпадать между рендерингами, что приведет к тому, что все ваши компоненты и DOM будут каждый раз пересоздаваться. Это не только медленно, но и приведет к потере любого пользовательского ввода внутри элементов списка. Вместо этого используйте стабильный идентификатор на основе данных.

// Обратите внимание, что ваши компоненты не получат ключ в качестве реквизита. Сам React использует его только как подсказку. Если вашему компоненту нужен идентификатор, вам необходимо передать его как отдельный реквизит: <Profile key={id} userId={id} />
//! Ловушка

//# Резюме
/*
На этой странице вы узнали:
- Как переместить данные из компонентов в структуры данных, такие как массивы и объекты.
- Как генерировать наборы похожих компонентов с помощью map JavaScript().
- Как создавать массивы отфильтрованных элементов с помощью JavaScript filter().
- Зачем и как устанавливать ключ для каждого компонента в коллекции, чтобы React мог отслеживать каждый из них, даже если их положение или данные изменяются.
*/
