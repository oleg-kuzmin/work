//# Передача реквизита в компонент
// Компоненты React используют реквизиты для взаимодействия друг с другом. Каждый родительский компонент может передавать некоторую информацию своим дочерним компонентам, передав им реквизиты. Свойства могут напоминать вам атрибуты HTML, но через них можно передавать любые значения JavaScript, включая объекты, массивы и функции.

/*
Ты выучишь:
- Как передать реквизиты компоненту
- Как читать реквизиты из компонента
- Как указать значения по умолчанию для реквизита
- Как передать JSX компоненту
- Как реквизит меняется со временем
*/

//# Знакомый реквизит
// Реквизит — это информация, которую вы передаете в тег JSX. Например, className, src, alt, width, height - некоторые из реквизитов, которые вы можете передать в <img>.

function Avatar() {
  return <img className="avatar" src="https://i.imgur.com/1bX5QH6.jpg" alt="Lin Lanying" width={100} height={100} />;
}

function Profile() {
  return <Avatar />;
}

// Свойства, которые вы можете передать в тег <img>, предопределены (ReactDOM соответствует стандарту HTML). Но вы можете передать любые реквизиты своим собственным компонентам, например <Avatar>, чтобы настроить их. Вот как!

//# Передача реквизита в компонент
// В этом коде компонент Profile не передает никаких реквизитов своему дочернему компоненту Avatar:
function Profile() {
  return <Avatar />;
}

// Вы можете передать в Avatar реквизит в два этапа.

//* Шаг 1. Передайте реквизиты дочернему компоненту.
// Сначала передайте некоторые реквизиты в Avatar. Например, давайте передадим два реквизита: person(объект) и size(число):
function Profile() {
  return <Avatar person={{ name: 'Lin Lanying', imageId: '1bX5QH6' }} size={100} />;
}

//* Примечание
// Если в person= вас смутили двойные фигурные скобки, помните, что это всего лишь объект внутри фигурных скобок JSX.
//* Примечание

// Теперь вы можете прочитать эти реквизиты внутри компонента Avatar.

//* Шаг 2. Прочтите реквизиты внутри дочернего компонента.
// Вы можете прочитать эти реквизиты, указав их имена - person, size, разделенные запятыми, внутри скобок сразу после function Avatar ({person, size}). Это позволяет использовать их внутри кода Avatar, как если бы вы использовали переменные (деструктуризация объекта).

function Avatar({ person, size }) {
  // person and size are available here
}

// Добавьте немного логики Avatar, которая использует реквизиты person и size для рендеринга, и все готово.

// Теперь вы можете настроить рендеринг Avatar разными способами с разными реквизитами.

//* utils.js
function getImageUrl(person, size = 's') {
  return 'https://i.imgur.com/' + person.imageId + size + '.jpg';
}

//* App.js
function Avatar({ person, size }) {
  return <img className="avatar" src={getImageUrl(person)} alt={person.name} width={size} height={size} />;
}

function Profile() {
  return (
    <div>
      <Avatar
        size={100}
        person={{
          name: 'Katsuko Saruhashi',
          imageId: 'YfeOqp2',
        }}
      />
      <Avatar
        size={80}
        person={{
          name: 'Aklilu Lemma',
          imageId: 'OKS67lh',
        }}
      />
      <Avatar
        size={50}
        person={{
          name: 'Lin Lanying',
          imageId: '1bX5QH6',
        }}
      />
    </div>
  );
}

// Реквизиты позволяют вам думать о родительских и дочерних компонентах независимо. Например, вы можете изменить использование внутренних реквизитов person или size в Profile, не задумываясь о том, как их использует Avatar. Аналогично вы можете изменить то, как Avatar использует эти реквизиты, не заглядывая в файл Profile.

// Вы можете думать о реквизите как о «ручках», которые можно регулировать. Они выполняют ту же роль, что и аргументы для функций — фактически реквизиты являются единственным аргументом вашего компонента! Функции компонента React принимают один аргумент — объект props:

function Avatar(props) {
  let person = props.person;
  let size = props.size;
  // ...
}

// Обычно вам не нужен весь объект props целиком, поэтому вы разбиваете его на отдельные реквизиты.

//! Ловушка
// Не пропустите пару скобок {} внутри () при объявлении реквизита:
function Avatar({ person, size }) {
  // ...
}

// Этот синтаксис называется «деструктуризацией» и эквивалентен чтению свойств из параметра функции:
function Avatar(props) {
  let person = props.person;
  let size = props.size;
  // ...
}
//! Ловушка

//# Указание значения по умолчанию для свойства
// Если вы хотите дать свойству значение по умолчанию, к которому можно будет вернуться, когда значение не указано, вы можете сделать это с помощью деструктуризации, поставив знак "=значение по умолчанию" сразу после параметра:

function Avatar({ person, size = 100 }) {
  // ...
}

// Теперь, если <Avatar person={...} /> рендерится без реквизита size, для параметра size будет установлено значение 100.

// Значение по умолчанию используется только в том случае, если свойство size отсутствует или если вы передаете size={undefined}. Но если вы передадите size={null} или size={0}, значение по умолчанию не будет использоваться.

//# Пересылка реквизитов с помощью синтаксиса распространения JSX
// Иногда передача реквизита становится очень повторяющейся:

function Profile({ person, size, isSepia, thickBorder }) {
  return (
    <div className="card">
      <Avatar person={person} size={size} isSepia={isSepia} thickBorder={thickBorder} />
    </div>
  );
}

// В повторяющемся коде нет ничего плохого — он может быть более разборчивым. Но иногда вы можете ценить краткость. Некоторые компоненты пересылают все свои реквизиты своим дочерним элементам, как этот Profile работает с Avatar. Поскольку они не используют ни один из своих реквизитов напрямую, имеет смысл использовать более краткий синтаксис «распространения»:

function Profile(props) {
  return (
    <div className="card">
      <Avatar {...props} />
    </div>
  );
}

// Это перенаправит все реквизиты Profile в Avatar без перечисления каждого из них.

// Используйте синтаксис распространения сдержанно. Если вы используете его в любом другом компоненте, что-то не так. Часто это означает, что вам следует разделить компоненты и передать дочерние элементы как JSX. Подробнее об этом дальше!

//# Передача JSX как детей
// Обычно теги браузера встраиваются друг в друга:
<div>
  <img />
</div>;

// Иногда вам захочется вложить свои собственные компоненты таким же образом:
<Card>
  <Avatar />
</Card>;

// Когда вы вкладываете какой-либо контент в тег JSX, родительский компонент получит этот контент в объекте свойств props с именем children. Например, компонент Card ниже получит набор реквизитов children (<Avatar />) и отобразит его в div-оболочке:

//* utils.jsx
function getImageUrl(person, size = 's') {
  return 'https://i.imgur.com/' + person.imageId + size + '.jpg';
}

//* Avatar.js
function Avatar({ person, size }) {
  return <img className="avatar" src={getImageUrl(person)} alt={person.name} width={size} height={size} />;
}

//* App.js
function Card({ children }) {
  return <div className="card">{children}</div>;
}
function Profile() {
  return (
    <Card>
      <Avatar
        size={100}
        person={{
          name: 'Katsuko Saruhashi',
          imageId: 'YfeOqp2',
        }}
      />
    </Card>
  );
}

// Попробуйте заменить <Avatar> внутри <Card> каким-нибудь текстом, чтобы увидеть, как компонент Card может обертывать любой вложенный контент. Ему не нужно «знать», что рендерится внутри него. Вы увидите этот гибкий шаблон во многих местах.

// Вы можете думать о компоненте с элементом children как о «дыре», которую могут «заполнить» его родительские компоненты с помощью произвольного JSX. Вы часто будете использовать свойство children для визуальных оберток: панелей, сеток и т. д.

//# Как реквизит меняется со временем
// Компонент Clock ниже получает два реквизита от родительского компонента: color и time. (Код родительского компонента опущен, поскольку он использует состояние, в которое мы пока не будем углубляться.)

//* Clock.js
function Clock({ color, time }) {
  return <h1 style={{ color: color }}>{time}</h1>;
}

// Этот пример показывает, что компонент может со временем получать разные реквизиты. Реквизит не всегда статичен! Здесь реквизит time меняется каждую секунду, а реквизит color меняется, когда вы выбираете другой цвет. Реквизиты отражают данные компонента в любой момент времени, а не только в начале.

// Однако реквизиты неизменяемы (иммутабельны) — термин из информатики, означающий «неизменяемый». Когда компоненту необходимо изменить свои свойства (например, в ответ на взаимодействие с пользователем или новые данные), ему придется «попросить» родительский компонент передать ему другие свойства — новый объект! Его старые реквизиты будут затем отброшены, и в конечном итоге движок JavaScript освободит занятую ими память.

// Не пытайтесь изменить реквизиты! Когда вам нужно отреагировать на ввод пользователя (например, изменить выбранный цвет), вам нужно будет «установить состояние», о чем вы можете узнать в разделе «Состояние: память компонента».

//# Резюме
/*
- Чтобы передать реквизиты, добавьте их в JSX, как и в случае с атрибутами HTML.
- Чтобы прочитать реквизиты, используйте синтаксис деструктуризации - function Avatar({ person, size }).
- Вы можете указать значение по умолчанию, например size = 100, которое используется для отсутствующих и реквизитов undefined.
- Вы можете пересылать все реквизиты с помощью синтаксиса расширения JSX - <Avatar {...props} />, но не злоупотребляйте им!
- Вложенный JSX внутри компонента, например <Avatar />, вложенный в <Card></Card> (<Card><Avatar /></Card>) появится в качестве свойства children компонента Card.
- Реквизиты - это моментальные снимки, доступные только для чтения: каждый рендер получает новую версию реквизитов.
- Вы не можете менять реквизит. Если вам нужна интерактивность, вам нужно будет установить состояние.
*/
