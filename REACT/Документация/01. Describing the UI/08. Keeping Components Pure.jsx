//# Поддержание чистоты компонентов
// Некоторые функции JavaScript являются чистыми. Чистые функции выполняют только вычисления и не более того. Строго записывая свои компоненты только как чистые функции, вы можете избежать целого класса непонятных ошибок и непредсказуемого поведения по мере роста вашей кодовой базы. Однако, чтобы получить эти преимущества, необходимо соблюдать несколько правил.

/* Ты выучишь
- Что такое чистота и как она помогает избежать ошибок
- Как сохранить чистоту компонентов, не допуская внесения изменений на этапе рендеринга
- Как использовать строгий режим для поиска ошибок в компонентах
*/

//# Чистота: компоненты в виде формул
/* В информатике (и особенно в мире функционального программирования) чистая функция — это функция со следующими характеристиками:
- Онa занимается своим делом. Онa не изменяет никакие объекты или переменные, существовавшие до ее вызова.
- Те же входы, тот же выход. Учитывая одни и те же входные данные, чистая функция всегда должна возвращать один и тот же результат.
*/

// Возможно, вы уже знакомы с одним примером чистых функций: математическими формулами.

/* Рассмотрим эту математическую формулу: y = 2x.
- Если x = 2, то y = 4. Всегда.
- Если x = 3, то y = 6. Всегда.
- Если x = 3, y иногда не будет равняться 9, –1 или 2,5 в зависимости от времени суток или состояния фондового рынка.
- Если y = 2x и x = 3, y всегда будет равно 6.
*/

// Если бы мы превратили это в функцию JavaScript, это выглядело бы так:
function double(number) {
  return 2 * number;
}

// В приведенном выше примере double — это чистая функция. Если вы передадите ему 3, он вернет 6. Всегда.

// React разработан вокруг этой концепции. React предполагает, что каждый написанный вами компонент — это чистая функция. Это означает, что компоненты React, которые вы пишете, всегда должны возвращать один и тот же JSX при одних и тех же входных данных:

//* App.js
function Recipe({ drinkers }) {
  return (
    <ol>
      <li>Boil {drinkers} cups of water.</li>
      <li>
        Add {drinkers} spoons of tea and {0.5 * drinkers} spoons of spice.
      </li>
      <li>Add {0.5 * drinkers} cups of milk to boil and sugar to taste.</li>
    </ol>
  );
}

function App() {
  return (
    <section>
      <h1>Spiced Chai Recipe</h1>
      <h2>For two</h2>
      <Recipe drinkers={2} />
      <h2>For a gathering</h2>
      <Recipe drinkers={4} />
    </section>
  );
}

// Когда вы передаете Drinkers={2} в Recipe, он возвращает JSX, содержащий 2 стакана воды. Всегда.

// Если вы передадите Drinkers={4}, он вернет JSX, содержащий 4 стакана воды. Всегда.

// Точно так же, как математическая формула.

// Вы можете думать о своих компонентах как о рецептах: если вы будете следовать им и не добавлять новые ингредиенты в процессе приготовления, вы каждый раз будете получать одно и то же блюдо. Это «блюдо» — это JSX, который компонент передает React для рендеринга.

//# Side Effects (Побочные эффекты): непредвиденные последствия
// Процесс рендеринга React всегда должен быть чистым. Компоненты должны возвращать только свой JSX и не изменять какие-либо объекты или переменные, существовавшие до рендеринга — это сделало бы их нечистыми!

// Вот компонент, который нарушает это правило:

//* App.js
let guest = 0;

function Cup() {
  guest = guest + 1; //! Плохо: изменение существующей переменной!
  return <h2>Tea cup for guest #{guest}</h2>;
}

function TeaSet() {
  return (
    <>
      <Cup />
      <Cup />
      <Cup />
    </>
  );
}

// Этот компонент читает и записывает переменную guest, объявленную вне него. Это означает, что вызов этого компонента несколько раз приведет к созданию разных JSX! Более того, если другие компоненты читают guest, они тоже будут создавать разные JSX, в зависимости от того, когда они были визуализированы! Это непредсказуемо.

// Возвращаясь к нашей формуле y = 2x, теперь, даже если x = 2, мы не можем доверять тому, что y = 4. Наши тесты могут провалиться, наши пользователи будут сбиты с толку, самолеты упадут с неба — вы можете видеть, к чему это приведет, к запутанным ошибкам!

// Вы можете исправить этот компонент, передав вместо него guest в качестве реквизита:

//* App.js
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

function TeaSet() {
  return (
    <>
      <Cup guest={1} />
      <Cup guest={2} />
      <Cup guest={3} />
    </>
  );
}

// Теперь ваш компонент чист, поскольку возвращаемый им JSX зависит только от реквизита guest.

// В общем, не следует ожидать, что ваши компоненты будут отображаться в каком-то определенном порядке. Не имеет значения, вызываете ли вы y = 2 x до или после y = 5 x: обе формулы будут разрешаться независимо друг от друга. Точно так же каждый компонент должен «думать сам за себя», а не пытаться координировать свои действия или зависеть от других во время рендеринга. Рендеринг похож на школьный экзамен: каждый компонент должен рассчитывать JSX самостоятельно!

//* ГЛУБОКОЕ ПОГРУЖЕНИЕ Обнаружение нечистых вычислений с помощью StrictMode
// Хотя вы, возможно, еще не использовали их все, в React есть три типа входных данных, которые вы можете прочитать во время рендеринга: props, state и context. Вы всегда должны рассматривать эти входные данные как доступные только для чтения.

// Если вы хотите что-то изменить в ответ на ввод пользователя, вам следует установить состояние вместо записи в переменную. Никогда не следует изменять ранее существовавшие переменные или объекты во время рендеринга вашего компонента.

// React предлагает «строгий режим», в котором во время разработки он вызывает функцию каждого компонента дважды. Вызывая функции компонента дважды, строгий режим помогает найти компоненты, нарушающие эти правила.

// Обратите внимание, как в исходном примере отображаются «Гость №2», «Гость №4» и «Гость №6» вместо «Гость №1», «Гость №2» и «Гость №3». Исходная функция была нечистой, поэтому ее двойной вызов сломал ее. Но фиксированная чистая версия работает, даже если функция каждый раз вызывается дважды. Чистые функции только вычисляют, поэтому их двойной вызов ничего не изменит — точно так же, как двойной вызов double(2) не меняет возвращаемого значения, а решение y = 2 x дважды не меняет значения y. Те же входы, те же результаты. Всегда.

// Строгий режим не влияет на рабочую среду, поэтому он не замедляет работу приложения для ваших пользователей. Чтобы выбрать строгий режим, вы можете обернуть корневой компонент в <React.StrictMode>. Некоторые платформы делают это по умолчанию.
//* ГЛУБОКОЕ ПОГРУЖЕНИЕ Обнаружение нечистых вычислений с помощью StrictMode

//# Локальная мутация: маленький секрет вашего компонента
// В приведенном выше примере проблема заключалась в том, что компонент изменил ранее существовавшую переменную во время рендеринга. Это часто называют «мутацией», чтобы это звучало немного страшнее. Чистые функции не изменяют переменные за пределами области действия функции или объекты, которые были созданы до вызова — это делает их нечистыми!

// Однако вполне нормально изменять переменные и объекты, которые вы только что создали во время рендеринга. В этом примере вы создаете массив [], присваиваете его переменной cups, а затем добавляете с помощью push в него дюжину чашек:

//* App.js
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

function TeaGathering() {
  let cups = [];
  for (let i = 1; i <= 12; i++) {
    cups.push(<Cup key={i} guest={i} />);
  }
  return cups;
}

// Если бы переменная cups или массив [] были созданы вне функции TeaGathering, это была бы огромная проблема! Вы бы изменили уже существующий объект, помещая элементы в этот массив.

// Однако это нормально, поскольку вы создали их во время одного и того же рендеринга внутри TeaGathering. Ни один код за пределами TeaGathering никогда не узнает, что это произошло. Это называется «локальная мутация» — это своего рода маленький секрет вашего компонента.

//# Где могут возникнуть побочные эффекты
// Хотя функциональное программирование во многом зависит от чистоты, в какой-то момент что-то должно измениться. В этом и суть программирования! Эти изменения — обновление экрана, запуск анимации, изменение данных — называются побочными эффектами. Это вещи, которые происходят «на стороне», а не во время рендеринга.

// В React побочные эффекты обычно находятся внутри обработчиков событий. Обработчики событий — это функции, которые React запускает, когда вы выполняете какое-либо действие, например, когда вы нажимаете кнопку. Несмотря на то, что обработчики событий определены внутри вашего компонента, они не запускаются во время рендеринга! Таким образом, обработчики событий не обязательно должны быть чистыми.

// Если вы исчерпали все другие варианты и не можете найти подходящий обработчик событий для своего побочного эффекта, вы все равно можете прикрепить его к возвращенному JSX с помощью вызова useEffect в своем компоненте. Это говорит React выполнить его позже, после рендеринга, когда будут разрешены побочные эффекты. Однако этот подход должен быть вашим последним средством.

// Если возможно, постарайтесь выразить свою логику только с помощью рендеринга. Вы будете удивлены, как далеко это может вас завести!

//* ГЛУБОКОЕ ПОГРУЖЕНИЕ Почему React заботится о чистоте?
/* Написание чистых функций требует некоторой привычки и дисциплины. Но это также открывает чудесные возможности:
- Ваши компоненты могут работать в другой среде, например на сервере! Поскольку они возвращают один и тот же результат для одних и тех же входных данных, один компонент может обслуживать множество пользовательских запросов.
- Вы можете повысить производительность, пропустив компоненты рендеринга, входные данные которых не изменились. Это безопасно, поскольку чистые функции всегда возвращают одни и те же результаты, поэтому их можно безопасно кэшировать.
- Если некоторые данные изменяются в середине рендеринга глубокого дерева компонентов, React может перезапустить рендеринг, не тратя время на завершение устаревшего рендеринга. Чистота позволяет безопасно прекратить расчеты в любой момент.
*/

// Каждая новая функция React, которую мы создаем, использует преимущества чистоты. От извлечения данных до анимации и производительности — поддержание чистоты компонентов раскрывает всю мощь парадигмы React.
//* ГЛУБОКОЕ ПОГРУЖЕНИЕ Почему React заботится о чистоте?

//# Резюме


