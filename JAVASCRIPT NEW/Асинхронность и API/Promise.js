/*
- Промисы — запросы на асинхронный код. Когда мы создаём промис, мы говорим движку: выполни вот этот код и по результатам переведи промис в статус «исполнен» или «отклонён».
- Часто промисы используют для запросов к какому-то устройству, например, к серверу.
- Запрос может быть исполнен или отклонён.
- Поэтому при создании промиса нужно описать, что делать в случае выполнения запроса, а что — в случае отказа.
- Чтобы «научить» движок обрабатывать запрос, функции Promise передают на вход функцию.
- Вы создаёте промис глобальной функцией Promise, которой передаёте на вход колбэк.
- Этот колбэк принимает на вход 2 функции, которые можно вызвать в теле колбэка.
- Первая функция — resolve. Она переводит промис в статус «исполнен», а значение, переданное этой функции, затем передаётся методу then.
- Вторая функция — reject. Она переводит промис в статус «отклонён». Переданное этой функции значение затем передаётся на вход методу catch.
- Параметры resolve и reject можно назвать и по-другому, но обычно им дают именно такие имена
- Поэтому, чтобы создать промис, нужно сначала вызвать функцию Promise, а затем описать в методах then и catch, что мы хотим делать в случае успеха, а что — в случае неудачи.
- Код функции, переданной функции Promise, исполняется немедленно.
- Как только вы откроете файл, движок запустит код промиса: создаст переменную rand, присвоит ей true или false.
*/

const newPromise = new Promise(function (resolve, reject) {
  const rand = Math.random() > 0.5 ? true : false;
  if (rand) {
    resolve('Запрос обработан успешно');
  } else {
    reject('Запрос отклонён');
  }
});

/*
- Затем нам нужно прописать логику: что делать движку, если промис будет обработан, и что — если отклонён.
- Для этого у промисов есть три метода:
1) then — выполнится, если промис исполнен
2) catch — если отклонён
3) finally — выполнится в любом случае независимо от статуса промиса
*/

newPromise
  .then(function (value) {
    // Если промис был обработан
    console.log(value);
    // Параметр value хранит значение, переданное методу resolve при создании промиса, то есть строку "Запрос обработан успешно"
  })
  .catch(function (value) {
    // Если промис был отклонён
    console.log(value + ', нам жаль :(');
    // Здесь параметр value будет хранить то значение, которое было передано методу reject, то есть строку "Запрос отклонён"
  })
  .finally(function () {
    // В любом случае
    console.log('Как бы там ни было — запрос мы в глаза видели');
  });

//# еще пример
function wait(ms) {
  return new Promise((resolve, reject) => {
    setTimeout(resolve, ms);
    reject(console.log('Ошибка'));
  });
}

wait(2000).then(() => console.log('Прошло 2000мс'));

//# Промисы позволяют добавлять задачи в асинхронную очередь. Для этого нужно дописать в коде ещё один then или catch.
// Всегда завершайте цепочки промисов блоком catch. Это позволит обработать ошибку, если она возникнет в любом then из цепочки.

const newPromise2 = new Promise(function (resolve, reject) {
  resolve('Раз'); // Сразу получим обработанный промис
});

function firstAction(value) {
  // Значением value станет то, что мы передали функции resolve при создании промиса. То есть строка "Раз".
  return `${value}, два`;
}

function secondAction(value) {
  // Тут значение value — это то, что вернёт предыдущий метод then, то есть строка "Раз, два"
  return `${value}, три`;
}

function thirdAction(value) {
  console.log(value);
}

newPromise2.then(firstAction).then(secondAction).then(thirdAction); // В консоли окажется: "Раз, два, три"

//# Promise.resolve() && Promise.reject()
// Если вы сразу хотите создать исполненный или отклонённый промис, вызывать new Promise необязательно. Можно обратиться к методам Promise.resolve и Promise.reject. Эти методы создают промис, переводят его в статус «исполнен» или «отклонён» соответственно, и записывают как результат промиса — то, что мы передали этим методам.

Promise.resolve('Этот промис исполнен').then(function (value) {
  console.log(value); // "Этот промис исполнен"
});

Promise.reject('Этот промис отклонён').catch(function (value) {
  console.log(value); // "Этот промис отклонён"
});

//# Promise.all()
// Он принимает на вход массив с промисами и выполняет записанный в then код, только когда все промисы вернулись со статусом «исполнен».

// Создаём первый промис
const firstPromise = new Promise((resolve, reject) => {
  if (someCondition) {
    resolve('Первый промис');
  } else {
    reject();
  }
});

// Создаём второй промис
const secondPromise = new Promise((resolve, reject) => {
  if (secondCondition) {
    resolve('Второй промис');
  } else {
    reject();
  }
});

// Создаём массив с промисами
const promises = [firstPromise, secondPromise];

// Передаём массив с промисами методу Promise.all
Promise.all(promises).then((results) => {
  console.log(results); // ["Первый промис", "Второй промис"]
});
