//# Object.assign (Копирование объекта)
/*
- При копировании объектов или массивов JavaScript копирует данные только на один уровень вглубь. Этот тип копирования называется поверхностным (shallow).
- Непримитивные типы данных, такие как массивы и объекты, хранятся по ссылке. Так как копирование происходит только на один уровень вглубь, то при копировании массива происходит копирование ссылок на старые объекты в новый массив.
- Если необходимо полностью скопировать сложную структуру данных, например, массив с объектами, то нужно делать глубокое (deep) или полное копирование данных. JavaScript не содержит функций для глубокого копирования, лучший вариант сделать глубокую копию — сериализовать структуру в JSON и тут же распарсить.
*/

//# синтаксис
Object.assign({}, objectDonor);
// Первый аргумент — объект-акцептор: скопированные ключи и их значения будут записаны в него.
// Второй и последующие аргументы — это объекты-доноры: из них будут скопированы все свойства.

//# поверхностное копирование
//* использование метода Object.assign()
const firstObj = {
  one: 1,
  two: 2,
};
const secondObj = Object.assign({}, firstObj);
console.log(secondObj === firstObj); // false

//* использование rest оператора
const superUser = {
  firstName: 'Марина',
  username: 'zloyDuh',
};
const copy = { ...superUser };
console.log(copy); // { firstName: 'Марина', username: 'zloyDuh'}

//# глубокое копирование
//* примерный алгоритм
/*
1) циклом начинаем проходить по всем свойствам объекта;
2) если встречаем примитивное свойство — копируем;
3) если встречаем свойство-объект — повторяем для него все шаги, начиная с первого.
*/

const original = {
  one: 1,
  two: 2,
  three: { message: 'I love JS' },
};

const copyObject = Object.assign({}, original); // копируем все примитивы и ссылки на объект
copyObject.three = Object.assign({}, original.three); // копируем объект внутри объекта

console.log(copyObject); // { one: 1, two: 2, three: { message: "I love JS" } } (это копия)
console.log(copyObject === original); // false
console.log(copyObject.three === original.three); // false

//* использование JSON
/*
У этого метода есть ограничение — копируемые данные должны быть сериализуемы.
Вот примеры несериализуемых данных: примитив undefined, функция, symbol - при вызове JSON.stringify получаем undefined.

Массивы и объекты - сериализуемы. Что будет если у них в качестве ключа или значения будут несериализуемые данные?
1) для массивов: такие значения будут превращены в null;
2) для объектов: такие значения будут опущены, а если symbol является ключом объекта, то он будет проигнорирован, даже при использовании функции replacer.
*/

const userDeepCopy = JSON.parse(JSON.stringify(user));
