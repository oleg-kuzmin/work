//# функции
// При написании функции указываются параметры — те переменные, с которыми работает функция. При вызове функции можно передать в нее аргументы. Если функцию передают как аргумент, её называют «колбэком».

//# function declaration
//* может принимать аргументы
function showMessage(user, message) {
  console.log(user + ": " + message);
}
//* использование параметра по умолчанию (text = "текст не добавлен")
function showMessage(from, text = "текст не добавлен") {
  console.log(from + ": " + text);
}
//* использование в качестве параметра по умолчанию вызов другой функции (text = anotherFunction())
function showMessage(from, text = anotherFunction()) {
  console.log(from + ": " + text);
  // если параметр text не передан, то выполнится функция anotherFunction()
}

//* рекурсивные функции (внутри функции вызывает сама себя)
function fac(n) {
  if (n < 2) {
    return 1;
  } else {
    return n * fac(n - 1);
  }
}
console.log(fac(3)); // 6

//# function expression
const hello = function (name) {
  console.log(`Привет ${name}`);
};

//# стрелочные функции (нет контекста выполнения)
//* одно выражение в правой части (можно опустить return)
let sum = (a, b) => a + b;

//* многострочный код (здесь нужен return)
let sum2 = (a, b) => {
  // какой-то код
  return a + b;
};

//* без аргументов
let sayHi = () => alert("Привет");

//* с одним аргументом (если аргумент один скобки можно опустить)
let double = (n) => n * 2;

//# общая информация
/* Основное отличие в том, что если мы использовали Function Declaration, то JavaScript перенесёт функции вверх текущей области видимости. Это называется «поднятие» (или hoisting).
- На практике это означает, что мы можем использовать Function Declaration до своего же объявления. Пишем — заработай, и где-то потом объясняем как.
- Обычно имя функции пишут стилем camelCase и используют в начале глагол. Отвечает на вопрос: что делает эта функция?.
- Переменные внутри функции существуют только внутри этой функции — этот эффект называется областью видимости.*/
