//# Создание регулярного выражения
// https://regex101.com/

//# Конструктор new RegExp()
// pattern - строка, содержащая регулярное выражение.
// flags - дополнительные флаги, определяющие, как будет работать регулярное выражение.
const regexConstructor = new RegExp('pattern', 'flags');
const regex1 = new RegExp('\\d', 'g'); // регулярное выражение, которое ищет все цифры в строке

//# Литералы
// Если вы планируете создавать регулярные выражения при помощи литералов, такой подход не позволяет изменять задаваемые значения динамически — литералы регулярных выражений компилируются заранее при анализе скрипта. Зато если ваше регулярное выражение постоянно, то литералы позволяют увеличить производительность.
const regex2 = /\d/g; // регулярное выражение, которое ищет все цифры в строке

//# Шаблоны и метасимволы
/*
Шаблоны — набор символов, которые используют для поиска определённых сочетаний символов в тексте.
Метасимволы — специальные символы, которые используют для составления шаблонов.

.       (любой одиночный символ (1 символ)
a       (одиночный символ a (1 символ)
a.      (символ a и еще один любой одиночный символ (2 символа)
a..     (символ a и еще два любых одиночных символа (3 символа)
[]      (любой одиночный символ из них, также можно указывать диапазоны
[aA]    (найдет одиночный символ a и одиночный символ A (не вместе)
[a-z]   (диапазон любой одиночный символ от a до z
\       (экранирование
$       (конец строки
^       (начало строки
\n      (перенос строки
[^a]    (отрицание, начинается с любого символа, не равного a
\d      (любая одиночная цифра (1 символ)
\d\d    (две любые одиночных цифры подряд (2 символа)
\D      (все что угодно кроме цифры
\s      (любой одиночный пробел
\S      (все что угодно кроме пробела
\w      (любая одиночная буква
\W      (все что угодно кроме букв и цифр
\b      (граница слова
\b...\b (слово из 3 букв (3 символа)
\B      (все, кроме границ слова

//* квантификация
1) {}       (квантификация (сколько символ должен повторятся)
2) a{4}     (выражение из 4 символов a подряд
3) a{4,6}   (выражение от 4 символов до 6 подряд
4) *        (выражение повторяется от 0 и выше
5) ab*      (ищет выражение a и b сколько угодно раз
6) +        (выражение повторяется от 1 и выше
7) ab+      (ищет выражение a и b как мининум один раз
8) ?        (выражение повторяется либо 0 либо 1

//* условия и группировка
(\s|-) - либо \s либо - (знак |)
*/

//# Квантификаторы
/* Квантификаторы — метасимволы, которые определяют количество повторений предыдущего символа.
1) {n}   (соответствует ровно n повторениям предыдущего символа.
2) {n,m} (соответствует от n до m повторений предыдущего символа.
3) {n,}  (соответствует n или более повторениям предыдущего символа.
4) ?     (делает предыдущий квантификатор ленивым, т. е. соответствует наименьшему возможному количеству повторений.
*/

const pattern1 = /a{3}/; // соответствует трём символам "a" подряд

//# Флаги
/* Модификаторы — cпециальные флаги, которые можно добавить к регулярному выражению для изменения его поведения.
1) g — глобальный поиск, ищет все совпадения в строке.
2) i — игнорирование регистра, игнорирует различия между верхним и нижним регистром.
3) m — многострочный поиск, позволяет искать совпадения в нескольких строках.
*/

const pattern2 = /test/gi; // соответствует строкам "test" или "Test" или "TEST" глобально и без учёта регистра

//# Группы и обратные ссылки
/*
- Группы — последовательности символов, заключённые в скобки (), которые могут повторяться с помощью квантификаторов.
- Группы также позволяют использовать обратные ссылки, которые ссылаются на результат совпадения группы в регулярном выражении.
- Обратная ссылка обозначается символом \ и номером группы, например, \1 ссылается на первую группу.
- В этом примере группа (\w+) соответствует любой последовательности символов, состоящей из буквенно-цифровых символов и подчёркивания. Затем \s соответствует пробелу, а \1 обратно ссылается на первую группу (\w+), так что регулярное выражение соответствует только тем строкам, в которых последовательность символов повторяется через пробел.
*/

const pattern3 = /(\w+)\s\1/; // соответствует повторяющейся последовательности символов, разделённой пробелом

//# Экранирование
/*
- Для экранирования символа используется обратный слеш \.
- Например, символ . в регулярном выражении означает любой символ, но если мы хотим использовать точку как обычный символ, мы можем экранировать его, написав \.
*/

//# Метод test()
// Метод test() проверяет, соответствует ли регулярное выражение заданной строке. Метод возвращает true, если строка соответствует регулярному выражению, и false, если не соответствует.
let str4 = 'Hello, world!';
const pattern4 = /Hello/;
pattern4.test(str4); // true

//# Метод exec()
// Метод exec() используется для поиска совпадений регулярного выражения в заданной строке. Метод возвращает массив, содержащий найденное совпадение и дополнительную информацию о нём.
let str5 = 'Hello, world!';
const pattern5 = /Hello/;
pattern5.exec(str5); // ["Hello", index: 0, input: "Hello, world!"]

//# Метод match()
// Метод match() используется для поиска всех совпадений регулярного выражения в заданной строке. Метод возвращает массив, содержащий все найденные совпадения.
let str6 = 'The quick brown fox jumps over the lazy dog.';
const pattern6 = /the/gi;
str6.match(pattern6); // ["the", "the"]

//# Метод replace()
// Метод replace() принимает два аргумента: регулярное выражение и строку, на которую нужно заменить найденное совпадение. Этот метод ищет все совпадения с заданным регулярным выражением в исходной строке и заменяет их на указанную строку.
let str7 = 'Привет, мир!';
const pattern7 = /мир/;
str7.replace(pattern7, 'земля'); // "Привет, земля!"

//# Метод search()
// Метод search() принимает один аргумент — регулярное выражение. Он ищет первое совпадение с заданным регулярным выражением в исходной строке и возвращает индекс первого символа совпадения начиная с 0. Если совпадение не найдено, метод возвращает -1.
let str8 = 'Это текст для примера';
const pattern8 = /текст/;
str8.search(pattern8); // 4

//# Метод split()
// Метод split() принимает один аргумент — регулярное выражение. Он разбивает исходную строку на массив подстрок, используя заданное регулярное выражение как разделитель.
let str9 = 'Это текст для примера';
const pattern9 = / /;
str9.split(pattern9); // ["Это", "текст", "для", "примера"]

//# Поиск всех цифр в тексте.
let str10 = 'Моя любимая цифра — 7, а у моего друга — 3.';
// экранируем метасимвол "\d", который обозначает цифру
const regex10 = /\d/g;
let result10 = str10.match(regex10);
console.log(result10); // ["7", "3"]

//# Замена всех пробелов на символ подчёркивания.
let str11 = 'Это пример строки с несколькими пробелами.';
// экранируем метасимвол "\s", который обозначает пробел
const regex11 = /\s/g;
let result11 = str11.replace(regex11, '_');
console.log(result11); // Это_пример_строки_с_несколькими_пробелами.

//# Замена всех точек в тексте на запятые, кроме точек, которые находятся внутри чисел.
let str12 = 'По отчёту за 2022 год выручка составила 12.345.678 рублей.';
// экранируем точку, используем негативный и позитивный просмотр вперёд и назад для исключения точек, находящихся внутри чисел
const regex12 = /(?<!\d)\.|\.(?!\d)/g;
let result12 = str12.replace(regex12, ',');
console.log(result12); // По отчёту за 2022 год выручка составила 12,345,678 рублей.

//# Примеры
/*
Набор из букв (латиница + кириллица), а также пробелов и дефисов
^([а-яА-ЯёЁa-zA-Z]|\s|-)+$

Номер кредитки:
[0-9]{13,16}

ICQ:
([1-9])+(?:-?\d){4,}

Набор из букв и цифр (латиница):
^[a-zA-Z0-9]+$

Набор из букв и цифр (латиница + кириллица):
^[а-яА-ЯёЁa-zA-Z0-9]+$

Домен (например abcd.com):
^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,6}$

IPv4: (подкорректировано runcore)
((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)

IPv6:
((^|:)([0-9a-fA-F]{0,4})){1,8}$

Имя пользователя (с ограничением 2-20 символов, которыми могут быть буквы и цифры, первый символ обязательно буква):
^[a-zA-Z][a-zA-Z0-9-_\.]{1,20}$

Пароль (Строчные и прописные латинские буквы, цифры):
^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?!.*\s).*$

Пароль (Строчные и прописные латинские буквы, цифры, спецсимволы. Минимум 8 символов):
(?=^.{8,}$)((?=.*\d)|(?=.*\W+))(?![.\n])(?=.*[A-Z])(?=.*[a-z]).*$

Дата в формате YYYY-MM-DD:
[0-9]{4}-(0[1-9]|1[012])-(0[1-9]|1[0-9]|2[0-9]|3[01])

UPD. Более строгая проверка, предложенная runcore:
(19|20)\d\d-((0[1-9]|1[012])-(0[1-9]|[12]\d)|(0[13-9]|1[012])-30|(0[13578]|1[02])-31)

Дата в формате DD/MM/YYYY:
(0[1-9]|[12][0-9]|3[01])[- /.](0[1-9]|1[012])[- /.](19|20)\d\d

Целые числа и числа с плавающей точкой (разделитель точка):
\-?\d+(\.\d{0,})?

UUID:
^[0-9A-Fa-f]{8}\-[0-9A-Fa-f]{4}\-[0-9A-Fa-f]{4}\-[0-9A-Fa-f]{4}\-[0-9A-Fa-f]{12}$

Широта или долгота:
-?\d{1,3}\.\d+

UPD. E-mail (от kvf77):
^[-\w.]+@([A-z0-9][-A-z0-9]+\.)+[A-z]{2,4}$

UPD. URL на латинице. Если нужно распознавать и кириллические домены, необходимо изменить все «a-z0-9» на «а-яёa-z0-9» и добавить в список доменных зон «рф» (от kvf77):
~^(?:(?:https?|ftp|telnet)://(?:[a-z0-9_-]{1,32}(?::[a-z0-9_-]{1,32})?@)?)?(?:(?:[a-z0-9-]{1,128}\.)+(?:ru|su|com|net|org|mil|edu|arpa|gov|biz|info|aero|inc|name|[a-z]{2})|(?!0)(?:(?!0[^.]|255)[0-9]{1,3}\.){3}(?!0|255)[0-9]{1,3})(?:/[a-z0-9.,_@%&?+=\~/-]*)?(?:#[^ '\"&]*)?$~i

UPD. Время в формате HH:MM:SS (от runcore):
^([0-1]\d|2[0-3])(:[0-5]\d){2}$

UPD. Mac-адрес (от tiahin):
([0-9a-fA-F]{2}([:-]|$)){6}$|([0-9a-fA-F]{4}([.]|$)){3}
*/
