//# Состояние как снимок
// Переменные состояния могут выглядеть как обычные переменные JavaScript, которые вы можете читать и записывать. Однако состояние больше похоже на снимок. Его установка не изменяет уже имеющуюся у вас переменную состояния, а вместо этого запускает повторный рендеринг.

/* Вы выучите:
- Как настройка состояния вызывает повторный рендеринг
- Когда и как обновляется состояние
- Почему состояние не обновляется сразу после его установки
- Как обработчики событий получают доступ к «моментальному снимку» состояния
*/

//# Настройка триггеров состояния рендеринга
// Вы можете думать о своем пользовательском интерфейсе как об изменении непосредственно в ответ на пользовательское событие, такое как щелчок. В React это работает немного иначе, чем эта ментальная модель. На предыдущей странице вы видели, что состояние настройки запрашивает повторный рендеринг из React. Это означает, что для того, чтобы интерфейс отреагировал на событие, вам необходимо обновить состояние.

// В этом примере, когда вы нажимаете "send", setIsSent(true) указывает React повторно отобразить пользовательский интерфейс:

import { useState } from 'react';

function Form() {
  const [isSent, setIsSent] = useState(false);
  const [message, setMessage] = useState('Hi!');
  if (isSent) {
    return <h1>Your message is on its way!</h1>;
  }
  return (
    <form
      onSubmit={e => {
        e.preventDefault();
        setIsSent(true);
        sendMessage(message);
      }}
    >
      <textarea placeholder="Message" value={message} onChange={e => setMessage(e.target.value)} />
      <button type="submit">Send</button>
    </form>
  );
}

function sendMessage(message) {
  // ...
}

/*
Вот что происходит, когда вы нажимаете кнопку:
1. Выполняется обработчик события onSubmit.
2. setIsSent(true) устанавливает для isSent значение true и ставит в очередь новый рендеринг.
3. React повторно отображает компонент в соответствии с новым значением isSent.
*/

// Давайте подробнее рассмотрим взаимосвязь между состоянием и рендерингом.

//# Рендеринг делает моментальный снимок во времени
// Рендеринг означает, что React вызывает ваш компонент, который является функцией. JSX, который вы возвращаете из этой функции, подобен моментальному снимку пользовательского интерфейса во времени. Его реквизиты, обработчики событий и локальные переменные были рассчитаны с использованием его состояния во время рендеринга.

// В отличие от фотографии или кадра фильма, «моментальный снимок» пользовательского интерфейса, который вы возвращаете, является интерактивным. Он включает в себя логику, такую как обработчики событий, которые определяют, что происходит в ответ на входные данные. React обновляет экран в соответствии с этим снимком и подключает обработчики событий. В результате нажатие кнопки вызовет обработчик кликов из вашего JSX.

/* Когда React перерисовывает компонент:
1. React снова вызывает вашу функцию.
2. Ваша функция возвращает новый снимок JSX.
3. Затем React обновляет экран в соответствии со снимком, который вы вернули.
*/

// Как память компонента, состояние не похоже на обычную переменную, которая исчезает после возврата из вашей функции. Состояние на самом деле «живет» в самом React — как будто на полке! — вне вашей функции. Когда React вызывает ваш компонент, он дает вам снимок состояния для этого конкретного рендеринга. Ваш компонент возвращает снимок пользовательского интерфейса со свежим набором реквизитов и обработчиков событий в своем JSX, и все они рассчитаны с использованием значений состояния из этого рендеринга!

// Вот небольшой эксперимент, чтобы показать вам, как это работает. В этом примере вы можете ожидать, что нажатие кнопки «+3» увеличит счетчик три раза, потому что он вызывает setNumber(number + 1) три раза.

// Посмотрите, что происходит, когда вы нажимаете кнопку «+3»:

import { useState } from 'react';

function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 1);
          setNumber(number + 1);
          setNumber(number + 1);
        }}
      >
        +3
      </button>
    </>
  );
}

// Обратите внимание, что число увеличивается только один раз за клик!

// Состояние настройки изменяет его только для следующего рендера. Во время первого рендеринга число было равно 0. Вот почему в обработчике onClick этого рендеринга значение числа по-прежнему равно 0 даже после вызова setNumber(number + 1):

/* Вот что обработчик нажатия этой кнопки сообщает React:

1. setNumber (number + 1): number равно 0, поэтому setNumber (0 + 1)
- React готовится изменить number на 1 при следующем рендеринге.

2. setNumber (number + 1): number равно 0, поэтому setNumber (0 + 1)
- React готовится изменить number на 1 при следующем рендеринге.

3. setNumber (number + 1): number равно 0, поэтому setNumber (0 + 1)
- React готовится изменить number на 1 при следующем рендеринге.
*/

// Несмотря на то, что вы вызвали setNumber(number + 1) три раза, в этом рендере обработчик событий number всегда равен 0, поэтому вы устанавливаете состояние 1 три раза. Вот почему после завершения обработчика событий React повторно отображает компонент с number равным 1, а не с 3.

// Вы также можете визуализировать это, мысленно заменяя переменные состояния их значениями в своем коде. Поскольку number переменная состояния предназначена 0 для этого рендера, его обработчик событий выглядит так:

<button
  onClick={() => {
    setNumber(0 + 1);
    setNumber(0 + 1);
    setNumber(0 + 1);
  }}
>
  +3
</button>;

// Для следующего рендера number равен 1, так что обработчик щелчка рендера выглядит так:

<button
  onClick={() => {
    setNumber(1 + 1);
    setNumber(1 + 1);
    setNumber(1 + 1);
  }}
>
  +3
</button>;

// Вот почему повторное нажатие на кнопку установит счетчик на 2, затем 3 на следующий щелчок и так далее.

//# Состояние с течением времени
// Что ж, это было весело. Попробуйте угадать, о чем будет предупреждать нажатие этой кнопки:

import { useState } from 'react';

function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 5);
          alert(number);
        }}
      >
        +5
      </button>
    </>
  );
}

// Если вы используете метод замены из предыдущего, вы можете догадаться, что предупреждение показывает «0»:

setNumber(0 + 5);
alert(0);

// Но что, если поставить таймер на предупреждение, чтобы оно срабатывало только после повторного рендеринга компонента? Будет ли он говорить «0» или «5»? Догадайся!

import { useState } from 'react';

function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 5);
          setTimeout(() => {
            alert(number);
          }, 3000);
        }}
      >
        +5
      </button>
    </>
  );
}

// Удивлен? Если вы используете метод подстановки, вы можете увидеть «моментальный снимок» состояния, переданного в alert.

setNumber(0 + 5);
setTimeout(() => {
  alert(0);
}, 3000);

// Состояние, хранящееся в React, могло измениться к моменту запуска оповещения, но оно было запланировано с использованием моментального снимка состояния на момент взаимодействия с ним пользователя!

// Значение переменной состояния никогда не изменяется в процессе рендеринга, даже если код обработчика событий является асинхронным. Внутри этого рендера onClick значение numberпродолжает оставаться 0даже после setNumber(number + 5)вызова. Его значение было «фиксировано», когда React «сделал снимок» пользовательского интерфейса, вызвав ваш компонент.

// Вот пример того, как это делает ваши обработчики событий менее подверженными ошибкам синхронизации. Ниже представлена ​​форма, которая отправляет сообщение с пятисекундной задержкой. Представьте себе этот сценарий:

// 1. Вы нажимаете кнопку «Отправить», отправляя «Привет» Алисе.
// 2. Прежде чем закончится пятисекундная задержка, вы измените значение поля «Кому» на «Боб».

// Что вы ожидаете от отображения alert? Будет ли он отображать «Вы поздоровались с Алисой»? Или он будет отображать «Вы поздоровались с Бобом»? Сделайте предположение, основанное на том, что вы знаете, а затем попробуйте:

import { useState } from 'react';

function Form() {
  const [to, setTo] = useState('Alice');
  const [message, setMessage] = useState('Hello');

  function handleSubmit(e) {
    e.preventDefault();
    setTimeout(() => {
      alert(`You said ${message} to ${to}`);
    }, 5000);
  }

  return (
    <form onSubmit={handleSubmit}>
      <label>
        To:{' '}
        <select value={to} onChange={e => setTo(e.target.value)}>
          <option value="Alice">Alice</option>
          <option value="Bob">Bob</option>
        </select>
      </label>
      <textarea placeholder="Message" value={message} onChange={e => setMessage(e.target.value)} />
      <button type="submit">Send</button>
    </form>
  );
}

// React сохраняет значения состояния «фиксированными» в обработчиках событий одного рендеринга. Вам не нужно беспокоиться о том, изменилось ли состояние во время выполнения кода.

// Но что, если вы хотите прочитать последнее состояние перед повторным рендерингом? Вы захотите использовать функцию обновления состояния, описанную на следующей странице!

//# Резюме
/*
- Состояние установки запрашивает новый рендеринг.
- React хранит состояние вне вашего компонента, как на полке.
- Когда вы вызываете useState, React дает вам снимок состояния для этого рендеринга .
- Переменные и обработчики событий не «выживают» при повторном рендеринге. Каждый рендер имеет свои обработчики событий.
- Каждый рендер (и функции внутри него) всегда будет «видеть» снимок состояния, которое React дал этому рендеру.
- Вы можете мысленно заменить состояние в обработчиках событий, подобно тому, как вы думаете об отрендеренном JSX.
- Обработчики событий, созданные в прошлом, имеют значения состояния из рендеринга, в котором они были созданы.
*/
