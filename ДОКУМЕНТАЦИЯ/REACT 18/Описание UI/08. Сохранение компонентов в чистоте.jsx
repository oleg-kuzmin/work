//# Сохранение компонентов в чистоте
// Некоторые функции JavaScript являются чистыми. Чистые функции выполняют только вычисления и ничего более. Строго записывая свои компоненты только как чистые функции, вы можете избежать целого класса непонятных ошибок и непредсказуемого поведения по мере роста вашей кодовой базы. Однако, чтобы получить эти преимущества, необходимо соблюдать несколько правил.

/* Вы выучите:
- Что такое чистота и как она помогает избежать ошибок
- Как сохранить компоненты чистыми, не допуская изменений на этапе рендеринга
- Как использовать строгий режим для поиска ошибок в ваших компонентах
*/

//# Чистота: компоненты в виде формул
/* В информатике (и особенно в мире функционального программирования) чистая функция — это функция со следующими характеристиками:

- Думает о своем собственном бизнесе. Не изменяет какие-либо объекты или переменные, существовавшие до ее вызова.
- Те же входы, тот же выход. При одних и тех же входных данных чистая функция всегда должна возвращать один и тот же результат.

Возможно, вы уже знакомы с одним примером чистых функций: формулами в математике.

Рассмотрим эту математическую формулу: y = 2x.

Если х = 2 , то у = 4 . Всегда.
Если х = 3 , то у = 6 . Всегда.
Если x = 3 , y иногда не будет равно 9 , -1 или 2,5 в зависимости от времени суток или состояния фондового рынка.

Если y = 2x и x = 3 , y всегда будет 6.

Если бы мы превратили это в функцию JavaScript, это выглядело бы так:
*/

function double(number) {
  return 2 * number;
}

// В приведенном выше примере double это чистая функция. Если вы вызовете ее с аргументом 3, она вернет 6. Всегда.

// React разработан вокруг этой концепции. React предполагает, что каждый написанный вами компонент является чистой функцией. Это означает, что компоненты React, которые вы пишете, должны всегда возвращать один и тот же JSX при одних и тех же входных данных:

function Recipe({ drinkers }) {
  return (
    <ol>
      <li>Boil {drinkers} cups of water.</li>
      <li>
        Add {drinkers} spoons of tea and {0.5 * drinkers} spoons of spice.
      </li>
      <li>Add {0.5 * drinkers} cups of milk to boil and sugar to taste.</li>
    </ol>
  );
}

function App() {
  return (
    <section>
      <h1>Spiced Chai Recipe</h1>
      <h2>For two</h2>
      <Recipe drinkers={2} />
      <h2>For a gathering</h2>
      <Recipe drinkers={4} />
    </section>
  );
}

// Когда вы пройдете drinkers={2} к Recipe, он вернет JSX, содержащий 2 cups of water. Всегда.

// Если вы пройдете drinkers={4}, он вернет JSX, содержащий файлы 4 cups of water. Всегда.

// Как математическая формула.

// Вы можете думать о своих компонентах как о рецептах: если вы будете следовать им и не добавлять новые ингредиенты в процессе приготовления, вы каждый раз будете получать одно и то же блюдо. Это «блюдо» — это JSX, который компонент использует для рендеринга React.

//# Побочные эффекты: непреднамеренные последствия
// Процесс рендеринга React всегда должен быть чистым. Компоненты должны возвращать только свой JSX, а не изменять какие-либо объекты или переменные, которые существовали до рендеринга — это сделает их нечистыми!

// Вот компонент, который нарушает это правило:
let guest = 0;

function Cup() {
  // Bad: changing a preexisting variable!
  guest = guest + 1;
  return <h2>Tea cup for guest #{guest}</h2>;
}

function TeaSet() {
  return (
    <>
      <Cup />
      <Cup />
      <Cup />
    </>
  );
}

// Этот компонент читает и записывает guest переменную, объявленную вне его. Это означает, что при многократном вызове этого компонента будет создаваться другой JSX! И более того, если другие компоненты читают guest, они также будут создавать разные JSX, в зависимости от того, когда они были обработаны! Это не предсказуемо.

// Возвращаясь к нашей формуле y = 2x , теперь, даже если x = 2 , мы не можем доверять тому, что y = 4 . Наши тесты могут провалиться, наши пользователи будут сбиты с толку, самолеты будут падать с неба — вы видите, как это может привести к запутанным ошибкам!

// Вы можете исправить этот компонент, передав guest вместо него props:

function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

function TeaSet() {
  return (
    <>
      <Cup guest={1} />
      <Cup guest={2} />
      <Cup guest={3} />
    </>
  );
}

// Теперь ваш компонент чистый, так как возвращаемый им JSX зависит только от свойства guest.

// В общем, вы не должны ожидать, что ваши компоненты будут отображаться в каком-то определенном порядке. Неважно, вызовете ли вы y = 2x до или после y = 5x : обе формулы разрешатся независимо друг от друга. Точно так же каждый компонент должен только «думать сам за себя», а не пытаться координировать свои действия или зависеть от других во время рендеринга. Рендеринг похож на школьный экзамен: каждый компонент должен вычислять JSX самостоятельно!

//* Обнаружение нечистых вычислений с помощью StrictMode
// Хотя вы, возможно, еще не использовали их все, в React есть три типа входных данных, которые вы можете прочитать во время рендеринга: свойства, состояние и контекст. Вы всегда должны рассматривать эти входные данные как доступные только для чтения.

// Когда вы хотите что-то изменить в ответ на ввод пользователя, вы должны установить состояние вместо записи в переменную. Вы никогда не должны изменять уже существующие переменные или объекты во время рендеринга вашего компонента.

// React предлагает «строгий режим», в котором функция каждого компонента вызывается дважды во время разработки. Дважды вызывая функции компонентов, строгий режим помогает найти компоненты, которые нарушают эти правила.

// Обратите внимание, что в исходном примере отображались «Гость № 2», «Гость № 4» и «Гость № 6» вместо «Гость № 1», «Гость № 2» и «Гость № 3». Исходная функция была нечистой, поэтому ее двойной вызов сломал ее. Но исправленная чистая версия работает, даже если функция каждый раз вызывается дважды. Чистые функции только вычисляют, поэтому их двойной вызов ничего не изменит — точно так же, как двойной вызов double(2) не меняет того, что возвращается, а решение y = 2x дважды не меняет того, что есть y. Те же входы, те же выходы. Всегда.

// Строгий режим не влияет на производительность, поэтому он не замедлит работу приложения для ваших пользователей. Чтобы выбрать строгий режим, вы можете обернуть корневой компонент в <React.StrictMode>. Некоторые фреймворки делают это по умолчанию.

//# Локальная мутация: маленький секрет вашего компонента
// В приведенном выше примере проблема заключалась в том, что компонент изменил ранее существовавшую переменную во время рендеринга. Это часто называют «мутацией», чтобы это звучало немного страшнее. Чистые функции не изменяют переменные вне области действия функции или объекты, которые были созданы до вызова — это делает их нечистыми!

// Однако совершенно нормально изменять переменные и объекты, которые вы только что создали во время рендеринга. В этом примере вы создаете [] массив, присваиваете его переменной cups, а затем добавляете push в него дюжину чашек:

function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

function TeaGathering() {
  let cups = [];
  for (let i = 1; i <= 12; i++) {
    cups.push(<Cup key={i} guest={i} />);
  }
  return cups;
}

// Если бы переменная cups или [] массив были созданы вне функции TeaGathering, это была бы огромная проблема! Вы бы изменили уже существующий объект, вставив элементы в этот массив.

// Однако это нормально, потому что вы создали их во время одного и того же рендера внутри TeaGathering. Никакой внешний код TeaGathering никогда не узнает, что это произошло. Это называется «локальной мутацией» — это что-то вроде маленького секрета вашего компонента.

//# Где вы можете вызвать побочные эффекты
// Хотя функциональное программирование сильно зависит от чистоты, в какой-то момент что-то должно измениться. В этом и смысл программирования! Эти изменения — обновление экрана, запуск анимации, изменение данных — называются побочными эффектами. Это вещи, которые происходят «на стороне» , а не во время рендеринга.

// В React побочные эффекты обычно принадлежат обработчикам событий. Обработчики событий — это функции, которые React запускает, когда вы выполняете какое-либо действие, например, когда вы нажимаете кнопку. Несмотря на то, что обработчики событий определены внутри вашего компонента, они не запускаются во время рендеринга! Таким образом, обработчики событий не должны быть чистыми.

// Если вы исчерпали все другие варианты и не можете найти правильный обработчик событий для вашего побочного эффекта, вы все равно можете прикрепить его к возвращенному JSX с помощью вызова useEffect в своем компоненте. Это говорит React выполнить его позже, после рендеринга, когда разрешены побочные эффекты. Тем не менее, этот подход должен быть вашим последним средством.

// По возможности старайтесь выразить свою логику только с помощью рендеринга. Вы будете удивлены, как далеко это может вас завести!

//* Почему React заботится о чистоте?
// Написание чистых функций требует некоторой привычки и дисциплины. Но это также открывает чудесные возможности:

// Ваши компоненты могут работать в другой среде, например на сервере! Поскольку они возвращают один и тот же результат для одних и тех же входных данных, один компонент может обслуживать множество пользовательских запросов.

// Вы можете повысить производительность, пропустив компоненты рендеринга, чьи входные данные не изменились. Это безопасно, потому что чистые функции всегда возвращают одни и те же результаты, поэтому их безопасно кэшировать.

// Если некоторые данные изменяются в середине рендеринга глубокого дерева компонентов, React может перезапустить рендеринг, не тратя время на завершение устаревшего рендеринга. Purity позволяет безопасно прекратить вычисления в любой момент.

// Каждая новая функция React, которую мы создаем, использует чистоту. От выборки данных до анимации и производительности — поддержание чистоты компонентов раскрывает всю мощь парадигмы React.

