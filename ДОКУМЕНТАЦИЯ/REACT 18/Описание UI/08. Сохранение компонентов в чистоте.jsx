//# Сохранение компонентов в чистоте
// Некоторые функции JavaScript являются чистыми. Чистые функции выполняют только вычисления и ничего более. Строго записывая свои компоненты только как чистые функции, вы можете избежать целого класса непонятных ошибок и непредсказуемого поведения по мере роста вашей кодовой базы. Однако, чтобы получить эти преимущества, необходимо соблюдать несколько правил.

/* Вы выучите:
- Что такое чистота и как она помогает избежать ошибок
- Как сохранить компоненты чистыми, не допуская изменений на этапе рендеринга
- Как использовать строгий режим для поиска ошибок в ваших компонентах
*/

//# Чистота: компоненты в виде формул
/* В информатике (и особенно в мире функционального программирования) чистая функция — это функция со следующими характеристиками:

- Думает о своем собственном бизнесе. Не изменяет какие-либо объекты или переменные, существовавшие до ее вызова.
- Те же входы, тот же выход. При одних и тех же входных данных чистая функция всегда должна возвращать один и тот же результат.

Возможно, вы уже знакомы с одним примером чистых функций: формулами в математике.

Рассмотрим эту математическую формулу: y = 2x.

Если х = 2 , то у = 4 . Всегда.
Если х = 3 , то у = 6 . Всегда.
Если x = 3 , y иногда не будет равно 9 , -1 или 2,5 в зависимости от времени суток или состояния фондового рынка.

Если y = 2x и x = 3 , y всегда будет 6.

Если бы мы превратили это в функцию JavaScript, это выглядело бы так:
*/

function double(number) {
  return 2 * number;
}

// В приведенном выше примере double это чистая функция. Если вы вызовете ее с аргументом 3, она вернет 6. Всегда.

// React разработан вокруг этой концепции. React предполагает, что каждый написанный вами компонент является чистой функцией. Это означает, что компоненты React, которые вы пишете, должны всегда возвращать один и тот же JSX при одних и тех же входных данных:

function Recipe({ drinkers }) {
  return (
    <ol>
      <li>Boil {drinkers} cups of water.</li>
      <li>
        Add {drinkers} spoons of tea and {0.5 * drinkers} spoons of spice.
      </li>
      <li>Add {0.5 * drinkers} cups of milk to boil and sugar to taste.</li>
    </ol>
  );
}

function App() {
  return (
    <section>
      <h1>Spiced Chai Recipe</h1>
      <h2>For two</h2>
      <Recipe drinkers={2} />
      <h2>For a gathering</h2>
      <Recipe drinkers={4} />
    </section>
  );
}

// Когда вы пройдете drinkers={2} к Recipe, он вернет JSX, содержащий 2 cups of water. Всегда.

// Если вы пройдете drinkers={4}, он вернет JSX, содержащий файлы 4 cups of water. Всегда.

// Как математическая формула.

// Вы можете думать о своих компонентах как о рецептах: если вы будете следовать им и не добавлять новые ингредиенты в процессе приготовления, вы каждый раз будете получать одно и то же блюдо. Это «блюдо» — это JSX, который компонент использует для рендеринга React.

//# Побочные эффекты: непреднамеренные последствия
// Процесс рендеринга React всегда должен быть чистым. Компоненты должны возвращать только свой JSX, а не изменять какие-либо объекты или переменные, которые существовали до рендеринга — это сделает их нечистыми!

// Вот компонент, который нарушает это правило:
let guest = 0;

function Cup() {
  // Bad: changing a preexisting variable!
  guest = guest + 1;
  return <h2>Tea cup for guest #{guest}</h2>;
}

function TeaSet() {
  return (
    <>
      <Cup />
      <Cup />
      <Cup />
    </>
  );
}

// Этот компонент читает и записывает guest переменную, объявленную вне его. Это означает, что при многократном вызове этого компонента будет создаваться другой JSX! И более того, если другие компоненты читают guest, они также будут создавать разные JSX, в зависимости от того, когда они были обработаны! Это не предсказуемо.

// Возвращаясь к нашей формуле y = 2x , теперь, даже если x = 2 , мы не можем доверять тому, что y = 4 . Наши тесты могут провалиться, наши пользователи будут сбиты с толку, самолеты будут падать с неба — вы видите, как это может привести к запутанным ошибкам!

// Вы можете исправить этот компонент, передав guest вместо него props:

function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

function TeaSet() {
  return (
    <>
      <Cup guest={1} />
      <Cup guest={2} />
      <Cup guest={3} />
    </>
  );
}

// Теперь ваш компонент чистый, так как возвращаемый им JSX зависит только от свойства guest.

// В общем, вы не должны ожидать, что ваши компоненты будут отображаться в каком-то определенном порядке. Неважно, вызовете ли вы y = 2x до или после y = 5x : обе формулы разрешатся независимо друг от друга. Точно так же каждый компонент должен только «думать сам за себя», а не пытаться координировать свои действия или зависеть от других во время рендеринга. Рендеринг похож на школьный экзамен: каждый компонент должен вычислять JSX самостоятельно!

//* Обнаружение нечистых вычислений с помощью StrictMode
// Хотя вы, возможно, еще не использовали их все, в React есть три типа входных данных, которые вы можете прочитать во время рендеринга: свойства, состояние и контекст. Вы всегда должны рассматривать эти входные данные как доступные только для чтения.

// Когда вы хотите что-то изменить в ответ на ввод пользователя, вы должны установить состояние вместо записи в переменную. Вы никогда не должны изменять уже существующие переменные или объекты во время рендеринга вашего компонента.

// React предлагает «строгий режим», в котором функция каждого компонента вызывается дважды во время разработки. Дважды вызывая функции компонентов, строгий режим помогает найти компоненты, которые нарушают эти правила.

// Обратите внимание, что в исходном примере отображались «Гость № 2», «Гость № 4» и «Гость № 6» вместо «Гость № 1», «Гость № 2» и «Гость № 3». Исходная функция была нечистой, поэтому ее двойной вызов сломал ее. Но исправленная чистая версия работает, даже если функция каждый раз вызывается дважды. Чистые функции только вычисляют, поэтому их двойной вызов ничего не изменит — точно так же, как двойной вызов double(2) не меняет того, что возвращается, а решение y = 2x дважды не меняет того, что есть y. Те же входы, те же выходы. Всегда.

// Строгий режим не влияет на производительность, поэтому он не замедлит работу приложения для ваших пользователей. Чтобы выбрать строгий режим, вы можете обернуть корневой компонент в <React.StrictMode>. Некоторые фреймворки делают это по умолчанию.

