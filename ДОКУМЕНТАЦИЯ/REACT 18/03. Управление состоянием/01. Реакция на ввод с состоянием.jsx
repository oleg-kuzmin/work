//# Реакция на ввод с состоянием
// React предоставляет декларативный способ управления пользовательским интерфейсом. Вместо прямого управления отдельными частями пользовательского интерфейса вы описываете различные состояния, в которых может находиться ваш компонент, и переключаетесь между ними в ответ на действия пользователя. Это похоже на то, как дизайнеры думают о пользовательском интерфейсе.

/* Вы выучите:
- Чем декларативное программирование пользовательского интерфейса отличается от императивного программирования пользовательского интерфейса
- Как перечислить различные визуальные состояния, в которых может находиться ваш компонент
- Как инициировать изменения между различными визуальными состояниями из кода
*/

//# Сравнение декларативного пользовательского интерфейса с императивным
/* Когда вы проектируете взаимодействия с пользовательским интерфейсом, вы, вероятно, думаете о том, как пользовательский интерфейс изменяется в ответ на действия пользователя. Рассмотрим форму, которая позволяет пользователю отправить ответ:

- Когда вы что-то вводите в форму, кнопка «Отправить» становится активной.
- Когда вы нажимаете «Отправить», и форма, и кнопка отключаются, и появляется счетчик .
- Если сетевой запрос выполнен успешно, форма скрывается и появляется сообщение «Спасибо» .
- Если сетевой запрос завершается неудачно, появляется сообщение об ошибке , и форма снова становится доступной .
*/

// В императивном программировании вышеизложенное напрямую соответствует тому, как вы реализуете взаимодействие. Вы должны написать точные инструкции для управления пользовательским интерфейсом в зависимости от того, что только что произошло. Вот еще один способ подумать об этом: представьте, что вы едете рядом с кем-то в машине и говорите им по очереди, куда ехать.

// Они не знают, куда вы хотите пойти, они просто следуют вашим командам. (И если вы ошибетесь, вы окажетесь не в том месте!) Это называется императивным , потому что вы должны «командовать» каждым элементом, от счетчика до кнопки, сообщая компьютеру, как обновить пользовательский интерфейс.

// В этом примере императивного программирования пользовательского интерфейса форма создается без использования React. Он использует только DOM браузера:

async function handleFormSubmit(e) {
  e.preventDefault();
  disable(textarea);
  disable(button);
  show(loadingMessage);
  hide(errorMessage);
  try {
    await submitForm(textarea.value);
    show(successMessage);
    hide(form);
  } catch (err) {
    show(errorMessage);
    errorMessage.textContent = err.message;
  } finally {
    hide(loadingMessage);
    enable(textarea);
    enable(button);
  }
}

function handleTextareaChange() {
  if (textarea.value.length === 0) {
    disable(button);
  } else {
    enable(button);
  }
}

function hide(el) {
  el.style.display = 'none';
}

function show(el) {
  el.style.display = '';
}

function enable(el) {
  el.disabled = false;
}

function disable(el) {
  el.disabled = true;
}

function submitForm(answer) {
  // Pretend it's hitting the network.
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (answer.toLowerCase() == 'istanbul') {
        resolve();
      } else {
        reject(new Error('Good guess but a wrong answer. Try again!'));
      }
    }, 1500);
  });
}

let form = document.getElementById('form');
let textarea = document.getElementById('textarea');
let button = document.getElementById('button');
let loadingMessage = document.getElementById('loading');
let errorMessage = document.getElementById('error');
let successMessage = document.getElementById('success');
form.onsubmit = handleFormSubmit;
textarea.oninput = handleTextareaChange;

// Императивное управление пользовательским интерфейсом работает достаточно хорошо для отдельных примеров, но в более сложных системах управлять им становится экспоненциально сложнее. Представьте, что вы обновляете страницу, полную различных форм, подобных этой. Добавление нового элемента пользовательского интерфейса или нового взаимодействия потребует тщательной проверки всего существующего кода, чтобы убедиться, что вы не внесли ошибку (например, забыли что-то показать или скрыть).

// React был создан, чтобы решить эту проблему.

// В React вы не управляете пользовательским интерфейсом напрямую — это означает, что вы не включаете, не отключаете, не показываете и не скрываете компоненты напрямую. Вместо этого вы объявляете, что хотите показать, а React выясняет, как обновить пользовательский интерфейс. Подумайте о том, чтобы сесть в такси и сказать водителю, куда вы хотите ехать, вместо того, чтобы указывать ему, где именно повернуть. Доставить вас туда — работа водителя, и они могут даже знать некоторые короткие пути, о которых вы не подумали!

//# Декларативное мышление о пользовательском интерфейсе
// Вы видели, как императивно реализовать форму выше. Чтобы лучше понять, как мыслить в React, вы выполните повторную реализацию этого пользовательского интерфейса в React ниже:

// 1. Определите различные визуальные состояния вашего компонента
// 2. Определите, что вызывает эти изменения состояния
// 3. Представьте состояние в памяти, используя useState
// 4. Удалите все несущественные переменные состояния
// 5. Подключите обработчики событий, чтобы установить состояние

//# Шаг 1. Определите различные визуальные состояния вашего компонента
// В компьютерных науках вы можете слышать о «машине состояний» , находящейся в одном из нескольких «состояний». Если вы работаете с дизайнером, возможно, вы видели мокапы для разных «визуальных состояний». React стоит на стыке дизайна и информатики, поэтому обе эти идеи являются источниками вдохновения.

// Во-первых, вам нужно визуализировать все различные «состояния» пользовательского интерфейса, которые может видеть пользователь:

// Пусто : в форме отключена кнопка «Отправить».
// Ввод : Форма имеет активную кнопку «Отправить».
// Отправка : Форма полностью отключена. Показан спиннер.
// Успех : вместо формы отображается сообщение «Спасибо».
// Ошибка : то же, что и состояние ввода, но с дополнительным сообщением об ошибке.

// Так же, как дизайнер, вы захотите «макетировать» или создавать «макеты» для различных состояний, прежде чем добавлять логику. Например, вот макет только для визуальной части формы. Этот макет управляется свойством, вызываемым status со значением по умолчанию 'empty':

function Form({ status = 'empty' }) {
  if (status === 'success') {
    return <h1>That's right!</h1>;
  }
  return (
    <>
      <h2>City quiz</h2>
      <p>In which city is there a billboard that turns air into drinkable water?</p>
      <form>
        <textarea />
        <br />
        <button>Submit</button>
      </form>
    </>
  );
}

// Вы можете назвать props как угодно, имя не имеет значения. Попробуйте отредактировать status = 'empty', чтобы status был равен 'success' и увидете сообщение об успешном завершении. Props позволяют вам быстро перебирать пользовательский интерфейс, прежде чем подключать какую-либо логику. Вот более конкретизированный прототип того же компонента, все еще «управляемый» реквизитом status:

function Form({
  // Try 'submitting', 'error', 'success':
  status = 'empty',
}) {
  if (status === 'success') {
    return <h1>That's right!</h1>;
  }
  return (
    <>
      <h2>City quiz</h2>
      <p>In which city is there a billboard that turns air into drinkable water?</p>
      <form>
        <textarea disabled={status === 'submitting'} />
        <br />
        <button disabled={status === 'empty' || status === 'submitting'}>Submit</button>
        {status === 'error' && <p className="Error">Good guess but a wrong answer. Try again!</p>}
      </form>
    </>
  );
}

//* Отображение множества визуальных состояний одновременно

// Если у компонента много визуальных состояний, может быть удобно показать их все на одной странице:

let statuses = ['empty', 'typing', 'submitting', 'success', 'error'];

function Form({ status }) {
  if (status === 'success') {
    return <h1>That's right!</h1>;
  }
  return (
    <form>
      <textarea disabled={status === 'submitting'} />
      <br />
      <button disabled={status === 'empty' || status === 'submitting'}>Submit</button>
      {status === 'error' && <p className="Error">Good guess but a wrong answer. Try again!</p>}
    </form>
  );
}

function App() {
  return (
    <>
      {statuses.map(status => (
        <section key={status}>
          <h4>Form ({status}):</h4>
          <Form status={status} />
        </section>
      ))}
    </>
  );
}

// Такие страницы часто называют «живыми руководствами по стилю» или «книгами историй».

//# Шаг 2. Определите, что вызывает эти изменения состояния
/*
Вы можете запускать обновления состояния в ответ на два типа входных данных:

- Человеческий ввод, например нажатие кнопки, ввод в поле, переход по ссылке.
- Компьютерные входные данные, такие как прибытие сетевого ответа, завершение тайм-аута, загрузка изображения.
*/

/*
В обоих случаях необходимо установить переменные состояния для обновления пользовательского интерфейса. Для формы, которую вы разрабатываете, вам нужно будет изменить состояние в ответ на несколько разных входных данных:

- Изменение ввода текста (человек) должно переключить его из пустого состояния в состояние ввода или обратно, в зависимости от того, пусто текстовое поле или нет.
- Нажатие кнопки «Отправить» (человек) должно переключить ее в состояние «Отправка» .
- Успешный сетевой ответ (компьютер) должен перевести его в состояние Success.
- Неудачный сетевой ответ (компьютер) должен перевести его в состояние Error с соответствующим сообщением об ошибке.
*/

//* Обратите внимание, что человеческий ввод часто требует обработчиков событий!

// Чтобы визуализировать этот поток, попробуйте нарисовать каждое состояние на бумаге в виде помеченного круга, а каждое изменение между двумя состояниями — в виде стрелки. Таким образом можно набросать множество потоков и разобраться с ошибками задолго до реализации.

// Empty => Typing => Submitting => Network error => Network success

//# Шаг 3: Представьте состояние в памяти с помощью useState
// Далее вам нужно представить визуальные состояния вашего компонента в памяти с помощью useState. Ключевым моментом является простота: каждая часть состояния является «движущейся частью», и вам нужно как можно меньше «движущихся частей». Большая сложность приводит к большему количеству ошибок!

// Начните с состояния, которое обязательно должно быть. Например, вам нужно сохранить answer для ввода и error (если он существует) для сохранения последней ошибки:

const [answer, setAnswer] = useState('');
const [error, setError] = useState(null);

// Затем вам понадобится переменная состояния, представляющая, какое из визуальных состояний вы хотите отобразить. Обычно существует более одного способа представить это в памяти, поэтому вам нужно поэкспериментировать с ним.

// Если вы изо всех сил пытаетесь сразу придумать лучший способ, начните с добавления достаточного количества состояний, чтобы быть уверенным , что охватываются все возможные визуальные состояния:

const [isEmpty, setIsEmpty] = useState(true);
const [isTyping, setIsTyping] = useState(false);
const [isSubmitting, setIsSubmitting] = useState(false);
const [isSuccess, setIsSuccess] = useState(false);
const [isError, setIsError] = useState(false);

// Ваша первая идея, скорее всего, не будет самой лучшей, но это нормально — состояние рефакторинга — это часть процесса!

//# Шаг 4. Удалите все ненужные переменные состояния.
// Вы хотите избежать дублирования содержимого состояния, чтобы отслеживать только то, что необходимо. Потратив немного времени на рефакторинг вашей структуры состояния, вы облегчите понимание своих компонентов, уменьшите дублирование и предотвратите непреднамеренное значение. Ваша цель — предотвратить случаи, когда состояние в памяти не представляет никакого допустимого пользовательского интерфейса, который вы хотели бы видеть пользователю. (Например, вы никогда не хотите одновременно отображать сообщение об ошибке и отключать ввод, иначе пользователь не сможет исправить ошибку!)

// Вот несколько вопросов, которые вы можете задать о своих переменных состояния:

// - Вызывает ли это состояние парадокс? Например, isTyping и isSubmitting не может быть одновременно true. Парадокс обычно означает, что состояние недостаточно ограничено. Существует четыре возможных комбинации двух логических значений, но только три соответствуют действительным состояниям. Чтобы удалить «невозможное» состояние, вы можете объединить их в status одно из трех значений: 'typing', 'submitting', или 'success'.

// - Доступна ли уже та же информация в другой переменной состояния? Еще один парадокс: isEmpty и isTyping не может быть true одновременно. Делая их отдельными переменными состояния, вы рискуете рассинхронизировать их и вызвать ошибки. К счастью, вы можете удалить isEmpty и вместо этого проверить answer.length === 0.

// - Можно ли получить ту же информацию из инверсии другой переменной состояния? isError не нужен, потому что вместо этого вы можете проверить error !== null.

// После этой очистки у вас осталось 3 (вместо 7!) основных переменных состояния:

const [answer2, setAnswer2] = useState('');
const [error2, setError2] = useState(null);
const [status2, setStatus2] = useState('typing'); // 'typing', 'submitting', or 'success'

// Вы знаете, что они необходимы, потому что вы не можете удалить ни один из них, не нарушив функциональность.

//* Устранение «невозможных» состояний с помощью редюсера
// Эти три переменные являются достаточно хорошим представлением состояния этой формы. Тем не менее, есть еще некоторые промежуточные состояния, которые не имеют полного смысла. Например, ненулевое значение error не имеет смысла, когда status есть 'success'. Чтобы точнее смоделировать состояние, вы можете извлечь его в редюсер. Редюсеры позволяют объединить несколько переменных состояния в один объект и объединить всю связанную логику!

//# Шаг 5: Подключите обработчики событий для установки состояния
