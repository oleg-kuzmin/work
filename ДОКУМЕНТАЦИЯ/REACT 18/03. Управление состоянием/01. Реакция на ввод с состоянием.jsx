//# Реакция на ввод с состоянием
// React предоставляет декларативный способ управления пользовательским интерфейсом. Вместо прямого управления отдельными частями пользовательского интерфейса вы описываете различные состояния, в которых может находиться ваш компонент, и переключаетесь между ними в ответ на действия пользователя. Это похоже на то, как дизайнеры думают о пользовательском интерфейсе.

/* Вы выучите:
- Чем декларативное программирование пользовательского интерфейса отличается от императивного программирования пользовательского интерфейса
- Как перечислить различные визуальные состояния, в которых может находиться ваш компонент
- Как инициировать изменения между различными визуальными состояниями из кода
*/

//# Сравнение декларативного пользовательского интерфейса с императивным
/* Когда вы проектируете взаимодействия с пользовательским интерфейсом, вы, вероятно, думаете о том, как пользовательский интерфейс изменяется в ответ на действия пользователя. Рассмотрим форму, которая позволяет пользователю отправить ответ:

- Когда вы что-то вводите в форму, кнопка «Отправить» становится активной.
- Когда вы нажимаете «Отправить», и форма, и кнопка отключаются, и появляется счетчик .
- Если сетевой запрос выполнен успешно, форма скрывается и появляется сообщение «Спасибо» .
- Если сетевой запрос завершается неудачно, появляется сообщение об ошибке , и форма снова становится доступной .
*/

// В императивном программировании вышеизложенное напрямую соответствует тому, как вы реализуете взаимодействие. Вы должны написать точные инструкции для управления пользовательским интерфейсом в зависимости от того, что только что произошло. Вот еще один способ подумать об этом: представьте, что вы едете рядом с кем-то в машине и говорите им по очереди, куда ехать.

// Они не знают, куда вы хотите пойти, они просто следуют вашим командам. (И если вы ошибетесь, вы окажетесь не в том месте!) Это называется императивным , потому что вы должны «командовать» каждым элементом, от счетчика до кнопки, сообщая компьютеру, как обновить пользовательский интерфейс.

// В этом примере императивного программирования пользовательского интерфейса форма создается без использования React. Он использует только DOM браузера:

async function handleFormSubmit(e) {
  e.preventDefault();
  disable(textarea);
  disable(button);
  show(loadingMessage);
  hide(errorMessage);
  try {
    await submitForm(textarea.value);
    show(successMessage);
    hide(form);
  } catch (err) {
    show(errorMessage);
    errorMessage.textContent = err.message;
  } finally {
    hide(loadingMessage);
    enable(textarea);
    enable(button);
  }
}

function handleTextareaChange() {
  if (textarea.value.length === 0) {
    disable(button);
  } else {
    enable(button);
  }
}

function hide(el) {
  el.style.display = 'none';
}

function show(el) {
  el.style.display = '';
}

function enable(el) {
  el.disabled = false;
}

function disable(el) {
  el.disabled = true;
}

function submitForm(answer) {
  // Pretend it's hitting the network.
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (answer.toLowerCase() == 'istanbul') {
        resolve();
      } else {
        reject(new Error('Good guess but a wrong answer. Try again!'));
      }
    }, 1500);
  });
}

let form = document.getElementById('form');
let textarea = document.getElementById('textarea');
let button = document.getElementById('button');
let loadingMessage = document.getElementById('loading');
let errorMessage = document.getElementById('error');
let successMessage = document.getElementById('success');
form.onsubmit = handleFormSubmit;
textarea.oninput = handleTextareaChange;

// Императивное управление пользовательским интерфейсом работает достаточно хорошо для отдельных примеров, но в более сложных системах управлять им становится экспоненциально сложнее. Представьте, что вы обновляете страницу, полную различных форм, подобных этой. Добавление нового элемента пользовательского интерфейса или нового взаимодействия потребует тщательной проверки всего существующего кода, чтобы убедиться, что вы не внесли ошибку (например, забыли что-то показать или скрыть).

// React был создан, чтобы решить эту проблему.

// В React вы не управляете пользовательским интерфейсом напрямую — это означает, что вы не включаете, не отключаете, не показываете и не скрываете компоненты напрямую. Вместо этого вы объявляете, что хотите показать, а React выясняет, как обновить пользовательский интерфейс. Подумайте о том, чтобы сесть в такси и сказать водителю, куда вы хотите ехать, вместо того, чтобы указывать ему, где именно повернуть. Доставить вас туда — работа водителя, и они могут даже знать некоторые короткие пути, о которых вы не подумали!

//# Декларативное мышление о пользовательском интерфейсе
// Вы видели, как императивно реализовать форму выше. Чтобы лучше понять, как мыслить в React, вы выполните повторную реализацию этого пользовательского интерфейса в React ниже:

// 1. Определите различные визуальные состояния вашего компонента
// 2. Определите, что вызывает эти изменения состояния
// 3. Представьте состояние в памяти, используя useState
// 4. Удалите все несущественные переменные состояния
// 5. Подключите обработчики событий, чтобы установить состояние

//# Шаг 1. Определите различные визуальные состояния вашего компонента
// В компьютерных науках вы можете слышать о «машине состояний» , находящейся в одном из нескольких «состояний». Если вы работаете с дизайнером, возможно, вы видели мокапы для разных «визуальных состояний». React стоит на стыке дизайна и информатики, поэтому обе эти идеи являются источниками вдохновения.

// Во-первых, вам нужно визуализировать все различные «состояния» пользовательского интерфейса, которые может видеть пользователь:

// Пусто : в форме отключена кнопка «Отправить».
// Ввод : Форма имеет активную кнопку «Отправить».
// Отправка : Форма полностью отключена. Показан спиннер.
// Успех : вместо формы отображается сообщение «Спасибо».
// Ошибка : то же, что и состояние ввода, но с дополнительным сообщением об ошибке.

// Так же, как дизайнер, вы захотите «макетировать» или создавать «макеты» для различных состояний, прежде чем добавлять логику. Например, вот макет только для визуальной части формы. Этот макет управляется свойством, вызываемым status со значением по умолчанию 'empty':

function Form({ status = 'empty' }) {
  if (status === 'success') {
    return <h1>That's right!</h1>;
  }
  return (
    <>
      <h2>City quiz</h2>
      <p>In which city is there a billboard that turns air into drinkable water?</p>
      <form>
        <textarea />
        <br />
        <button>Submit</button>
      </form>
    </>
  );
}

// Вы можете назвать props как угодно, имя не имеет значения. Попробуйте отредактировать status = 'empty', чтобы status был равен 'success' и увидете сообщение об успешном завершении. Props позволяют вам быстро перебирать пользовательский интерфейс, прежде чем подключать какую-либо логику. Вот более конкретизированный прототип того же компонента, все еще «управляемый» реквизитом status:

function Form({
  // Try 'submitting', 'error', 'success':
  status = 'empty',
}) {
  if (status === 'success') {
    return <h1>That's right!</h1>;
  }
  return (
    <>
      <h2>City quiz</h2>
      <p>In which city is there a billboard that turns air into drinkable water?</p>
      <form>
        <textarea disabled={status === 'submitting'} />
        <br />
        <button disabled={status === 'empty' || status === 'submitting'}>Submit</button>
        {status === 'error' && <p className="Error">Good guess but a wrong answer. Try again!</p>}
      </form>
    </>
  );
}

//* Отображение множества визуальных состояний одновременно

// Если у компонента много визуальных состояний, может быть удобно показать их все на одной странице:

let statuses = ['empty', 'typing', 'submitting', 'success', 'error'];

function Form({ status }) {
  if (status === 'success') {
    return <h1>That's right!</h1>;
  }
  return (
    <form>
      <textarea disabled={status === 'submitting'} />
      <br />
      <button disabled={status === 'empty' || status === 'submitting'}>Submit</button>
      {status === 'error' && <p className="Error">Good guess but a wrong answer. Try again!</p>}
    </form>
  );
}

function App() {
  return (
    <>
      {statuses.map(status => (
        <section key={status}>
          <h4>Form ({status}):</h4>
          <Form status={status} />
        </section>
      ))}
    </>
  );
}

// Такие страницы часто называют «живыми руководствами по стилю» или «книгами историй».

//# Шаг 2. Определите, что вызывает эти изменения состояния
