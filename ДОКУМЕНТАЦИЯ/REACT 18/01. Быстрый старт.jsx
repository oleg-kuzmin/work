//# Быстрый старт
// Добро пожаловать в документацию React! Эта страница познакомит вас с 80% концепций React, которые вы будете использовать ежедневно.

/* Вы выучите:
- Как создавать и вкладывать компоненты
- Как добавить разметку и стили
- Как отображать данные
- Как отображать условия и списки
- Как реагировать на события и обновлять экран
- Как обмениваться данными между компонентами
*/

//# Создание и вложение компонентов
// Приложения React состоят из компонентов. Компонент — это часть UI (пользовательского интерфейса), которая имеет собственную логику и внешний вид. Компонент может быть маленьким, как кнопка, или большим, как целая страница.

// Компоненты React — это функции JavaScript, которые возвращают разметку:

function MyButton() {
  return <button>I'm a button</button>;
}

// Теперь, когда вы объявили MyButton, вы можете вложить его в другой компонент:

function MyApp() {
  return (
    <div>
      <h1>Welcome to my app</h1>
      <MyButton />
    </div>
  );
}

// Обратите внимание, что <MyButton /> начинается с заглавной буквы. Вот как вы узнаете, что это компонент React. Имена компонентов React всегда должны начинаться с заглавной буквы, а теги HTML должны быть строчными.

// Ключевые слова экспорта по умолчанию определяют главный компонент в файле. Если вы не знакомы с какой-либо частью синтаксиса JavaScript, MDN (https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export) и javascript.info (https://javascript.info/import-export) содержат отличные ссылки.

//# Написание разметки с помощью JSX
// Синтаксис разметки, который вы видели выше, называется JSX. Это необязательно, но большинство проектов React используют JSX для удобства. Все инструменты, которые мы рекомендуем для локальной разработки, поддерживают JSX «из коробки».

// JSX строже, чем HTML. Вы должны закрыть теги типа <br />. Ваш компонент также не может возвращать несколько тегов JSX. Вы должны обернуть их в общий родитель, например <div>...</div> или пустую оболочку <>...</>:

function AboutPage() {
  return (
    <>
      <h1>About</h1>
      <p>
        Hello there.
        <br />
        How do you do?
      </p>
    </>
  );
}

// Если у вас есть много HTML для переноса в JSX, вы можете использовать онлайн-конвертер (https://transform.tools/html-to-jsx).

//# Добавление стилей
// В React вы указываете класс CSS с помощью className. Он работает так же, как атрибут класса HTML:

<img className="avatar" />;

// Затем вы пишете правила CSS для него в отдельном файле CSS:

//* css
// .avatar {
//   border-radius: 50%;
// }

// React не предписывает, как добавлять файлы CSS. В самом простом случае вы добавите тег <link> в свой HTML. Если вы используете инструмент сборки или фреймворк, обратитесь к его документации, чтобы узнать, как добавить файл CSS в свой проект.

//# Отображение данных
// JSX позволяет размещать разметку в JavaScript. Фигурные скобки позволяют вам «уйти обратно» в JavaScript, чтобы вы могли внедрить какую-то переменную из своего кода и отобразить ее пользователю. Например, это отобразит user.name:

function Data() {
  return <h1>{user.name}</h1>;
}

// Вы также можете «убежать в JavaScript» из атрибутов JSX, но вам нужно использовать фигурные скобки вместо кавычек. Например, className="avatar" передает строку "аватар" как класс CSS, но src={user.imageUrl} считывает значение переменной JavaScript user.imageUrl, а затем передает это значение как атрибут src:

function Data2() {
  return <img className="avatar" src={user.imageUrl} />;
}

// Вы также можете поместить более сложные выражения в фигурные скобки JSX, например, конкатенацию строк:

const user = {
  name: 'Hedy Lamarr',
  imageUrl: 'https://i.imgur.com/yXOvdOSs.jpg',
  imageSize: 90,
};

function Profile() {
  return (
    <>
      <h1>{user.name}</h1>
      <img
        className="avatar"
        src={user.imageUrl}
        alt={'Photo of ' + user.name}
        style={{
          width: user.imageSize,
          height: user.imageSize,
        }}
      />
    </>
  );
}

// В приведенном выше примере style={{}} не является специальным синтаксисом, а является обычным объектом {} внутри фигурных скобок style={ } JSX. Вы можете использовать атрибут стиля, когда ваши стили зависят от переменных JavaScript.

//# Условный рендеринг
// В React нет специального синтаксиса для написания условий. Вместо этого вы будете использовать те же приемы, что и при написании обычного кода JavaScript. Например, вы можете использовать оператор if для условного включения JSX:

function Login() {
  let content;
  if (isLoggedIn) {
    content = <AdminPanel />;
  } else {
    content = <LoginForm />;
  }
  return <div>{content}</div>;
}

// Если вы предпочитаете более компактный код, вы можете использовать условный оператор "?". В отличие от if, он работает внутри JSX:

function Login2() {
  <div>{isLoggedIn ? <AdminPanel /> : <LoginForm />}</div>;
}

// Если вам не нужна ветвь else, вы также можете использовать более короткий логический синтаксис &&:

<div>{isLoggedIn && <AdminPanel />}</div>;

// Все эти подходы также работают для атрибутов с условным указанием. Если вы не знакомы с некоторыми элементами этого синтаксиса JavaScript, вы можете начать с постоянного использования if...else.

//# Создание списков
// Вы будете полагаться на функции JavaScript, такие как цикл for и функцию массива map() для отображения списков компонентов.

// Например, допустим, у вас есть набор продуктов:

const products = [
  { title: 'Cabbage', id: 1 },
  { title: 'Garlic', id: 2 },
  { title: 'Apple', id: 3 },
];

// Внутри вашего компонента используйте функцию map() для преобразования массива продуктов в массив элементов <li>:

function List() {
  const listItems = products.map(product => <li key={product.id}>{product.title}</li>);
  return <ul>{listItems}</ul>;
}

// Обратите внимание, что <li> имеет атрибут key. Для каждого элемента в списке вы должны передать строку или число, которое однозначно идентифицирует этот элемент среди его братьев и сестер. Обычно ключ должен исходить из ваших данных, таких как идентификатор базы данных. React использует ваши ключи, чтобы узнать, что произойдет, если вы позже вставите, удалите или измените порядок элементов.

const products2 = [
  { title: 'Cabbage', isFruit: false, id: 1 },
  { title: 'Garlic', isFruit: false, id: 2 },
  { title: 'Apple', isFruit: true, id: 3 },
];

function ShoppingList() {
  const listItems = products2.map(product => (
    <li
      key={product.id}
      style={{
        color: product.isFruit ? 'magenta' : 'darkgreen',
      }}
    >
      {product.title}
    </li>
  ));

  return <ul>{listItems}</ul>;
}

//# Реагирование на события
// Вы можете реагировать на события, объявляя функции обработчиков событий внутри ваших компонентов:

function MyButton() {
  function handleClick() {
    alert('You clicked me!');
  }

  return <button onClick={handleClick}>Click me</button>;
}

// Обратите внимание, что onClick={handleClick} не имеет круглых скобок в конце! Не вызывайте функцию обработчика событий: вам нужно только передать ее вниз. React вызовет ваш обработчик событий, когда пользователь нажмет кнопку.

//# Обновление экрана
// Часто вам нужно, чтобы ваш компонент «запоминал» некоторую информацию и отображал ее. Например, может быть, вы хотите подсчитать, сколько раз была нажата кнопка. Для этого добавьте состояние к вашему компоненту.

// Во-первых, импортируйте useState из React:

import { useState } from 'react';

// Теперь вы можете объявить переменную состояния внутри вашего компонента:

function MyButton() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return <button onClick={handleClick}>Clicked {count} times</button>;
}

// Вы получите две вещи от useState: текущее состояние (count) и функцию, которая позволяет вам его обновить (setCount). Вы можете давать им любые имена, но принято писать [что-то, установить (set) что-то].

// React снова вызовет функцию вашего компонента. На этот раз счет будет 1. Затем будет 2. И так далее.

// Если вы визуализируете один и тот же компонент несколько раз, каждый из них получит свое собственное состояние. Нажмите каждую кнопку отдельно:

import { useState } from 'react';

function MyApp() {
  return (
    <div>
      <h1>Counters that update separately</h1>
      <MyButton />
      <MyButton />
    </div>
  );
}

function MyButton() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return <button onClick={handleClick}>Clicked {count} times</button>;
}

// Обратите внимание, как каждая кнопка «запоминает» свое собственное состояние счетчика и не влияет на другие кнопки.

//# Использование хуков
// Функции, начинающиеся с use, называются хуками. useState — это встроенный хук, предоставляемый React. Вы можете найти другие встроенные хуки в справочнике по API. Вы также можете написать свои собственные хуки, комбинируя существующие.

// Хуки имеют более строгие ограничения, чем другие функции. Вы можете вызывать хуки только в верхней части ваших компонентов (или других хуков). Если вы хотите использовать useState в условии или цикле, извлеките новый компонент и поместите его туда.

//# Обмен данными между компонентами
// В предыдущем примере у каждой MyButton был собственный независимый счетчик, и при нажатии каждой кнопки менялся только счетчик нажатой кнопки:

/*
//* Изначально состояние счетчика каждой кнопки MyButton равно 0.
MyApp
  MyButton (count: 0)
  MyButton (count: 0)
MyApp

//* Первый MyButton обновляет свой счетчик до 1.
MyApp
  MyButton (count: 1)
  MyButton (count: 0)
MyApp
*/

// Однако часто вам потребуются компоненты для обмена данными и постоянного обновления вместе.

// Чтобы оба компонента MyButton отображали одно и то же число и обновлялись вместе, вам нужно переместить состояние от отдельных кнопок «вверх» к ближайшему компоненту, содержащему их все.

// В данном примере MyApp:

/*
//* Первоначально состояние счетчика MyApp равно 0 и передается обоим дочерним элементам.
MyApp (count: 0)
  MyButton (0)
  MyButton (0)
MyApp

//* При щелчке MyApp обновляет состояние счетчика до 1 и передает его обоим дочерним элементам.
MyApp (count: 1)
  MyButton (1)
  MyButton (1)
MyApp
*/

// Теперь, когда вы нажмете любую кнопку, счетчик в MyApp изменится, что изменит оба счетчика в MyButton. Вот как это можно выразить в коде.

// Во-первых, переместите состояние из MyButton в MyApp:

function MyApp() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return (
    <div>
      <h1>Counters that update separately</h1>
      <MyButton />
      <MyButton />
    </div>
  );
}

function MyButton() {
  // ... we're moving code from here ...
}

// Затем передайте состояние из MyApp в каждую MyButton вместе с общим обработчиком кликов. Вы можете передавать информацию в MyButton с помощью фигурных скобок JSX, точно так же, как вы делали это раньше со встроенными тегами, такими как <img>:

function MyApp() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return (
    <div>
      <h1>Counters that update together</h1>
      <MyButton count={count} onClick={handleClick} />
      <MyButton count={count} onClick={handleClick} />
    </div>
  );
}

// Информация, которую вы передаете таким образом, называется props. Теперь компонент MyApp содержит состояние счетчика и обработчик события handleClick и передает их оба в качестве props каждой из кнопок.

// Наконец, измените MyButton, чтобы он считывал реквизиты, которые вы передали из его родительского компонента:

function MyButton({ count, onClick }) {
  return <button onClick={onClick}>Clicked {count} times</button>;
}

// Когда вы нажимаете кнопку, срабатывает обработчик onClick. Свойство onClick каждой кнопки было установлено на функцию handleClick внутри MyApp, поэтому код внутри него выполняется. Этот код вызывает setCount(count 1), увеличивая переменную состояния count. Новое значение счетчика передается в качестве реквизита каждой кнопке, поэтому все они показывают новое значение. Это называется lifting state up («подъем состояния вверх»). Перемещая состояние вверх, вы делите его между компонентами.

import { useState } from 'react';

function MyApp() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return (
    <div>
      <h1>Counters that update together</h1>
      <MyButton count={count} onClick={handleClick} />
      <MyButton count={count} onClick={handleClick} />
    </div>
  );
}

function MyButton({ count, onClick }) {
  return <button onClick={onClick}>Clicked {count} times</button>;
}
