//# Постановка в очередь серии обновлений состояния
// Установка переменной состояния поставит в очередь другой рендеринг. Но иногда вы можете захотеть выполнить несколько операций над значением перед постановкой в ​​очередь следующего рендеринга. Для этого полезно понять, как React пакетно обновляет состояние.

/* Вы выучите:
- Что такое «пакетная обработка» и как React использует ее для обработки нескольких обновлений состояния
- Как применить несколько обновлений к одной и той же переменной состояния подряд
*/

//# Обновления состояния пакетов React
// Вы можете ожидать, что нажатие кнопки «+3» увеличит счетчик три раза, потому что он вызывается setNumber(number + 1) три раза:

import { useState } from 'react';

function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 1);
          setNumber(number + 1);
          setNumber(number + 1);
        }}
      >
        +3
      </button>
    </>
  );
}

// Однако, как вы, возможно, помните из предыдущего раздела, значения состояния каждого рендеринга фиксированы, поэтому значение number внутри обработчика событий первого рендеринга всегда равно 0, независимо от того, сколько раз вы вызываете setNumber(1):

setNumber(0 + 1);
setNumber(0 + 1);
setNumber(0 + 1);

// Но здесь действует еще один фактор. React ждет, пока весь код в обработчиках событий не будет запущен, прежде чем обрабатывать ваши обновления состояния. Вот почему повторный рендеринг происходит только после всех этих setNumber() вызовов.

// Это может напомнить вам официанта, принимающего заказ в ресторане. Официант не бежит на кухню при упоминании вашего первого блюда! Вместо этого они позволяют вам закончить свой заказ, позволяют вносить в него изменения и даже принимать заказы от других людей за столом.

// Это позволяет вам обновлять несколько переменных состояния — даже из нескольких компонентов — без запуска слишком большого количества повторных рендерингов. Но это также означает, что пользовательский интерфейс не будет обновляться до тех пор , пока ваш обработчик событий и любой код в нем не завершатся. Такое поведение, также известное как пакетная обработка, позволяет вашему приложению React работать намного быстрее. Это также позволяет избежать сбивающих с толку «недоделанных» рендеров, в которых были обновлены только некоторые переменные.

// React не объединяет несколько преднамеренных событий, таких как клики , — каждый клик обрабатывается отдельно. Будьте уверены, что React выполняет пакетную обработку только тогда, когда это безопасно. Это гарантирует, что, например, если первый щелчок кнопки отключит форму, второй щелчок не отправит ее снова.

//# Обновление одного и того же состояния несколько раз перед следующим рендерингом
// Это необычный вариант использования, но если вы хотите обновить одну и ту же переменную состояния несколько раз перед следующим рендерингом, вместо передачи следующего значения состояния, такого как setNumber(number + 1), вы можете передать функцию , которая вычисляет следующее состояние на основе предыдущего в очередь вроде setNumber(n => n + 1). Это способ сказать React «сделать что-нибудь со значением состояния», а не просто заменить его.

import { useState } from 'react';

function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(n => n + 1);
          setNumber(n => n + 1);
          setNumber(n => n + 1);
        }}
      >
        +3
      </button>
    </>
  );
}

/* Здесь n => n + 1 называется функцией обновления. Когда вы передаете его установщику состояния:
1. React ставит эту функцию в очередь для обработки после выполнения всего остального кода в обработчике событий.
2. Во время следующего рендеринга React проходит через очередь и выдает вам окончательное обновленное состояние.
*/

setNumber(n => n + 1);
setNumber(n => n + 1);
setNumber(n => n + 1);

/* Вот как React работает с этими строками кода при выполнении обработчика событий:
setNumber(n => n + 1): n => n + 1 это функция. React добавляет его в очередь.
setNumber(n => n + 1): n => n + 1 это функция. React добавляет его в очередь.
setNumber(n => n + 1): n => n + 1 это функция. React добавляет его в очередь.
*/

/* Когда вы вызываете useState во время следующего рендера, React проходит через очередь. Предыдущее состояние number было 0, поэтому React передает его первой функции обновления в качестве nаргумента. Затем React берет возвращаемое значение вашей предыдущей функции обновления и передает его следующему обновлению как n и так далее:

обновление в очереди	n	    возвращается
n => n + 1	          0	    0 + 1 = 1
n => n + 1	          1	    1 + 1 = 2
n => n + 1	          2	    2 + 1 = 3
*/

// React сохраняет 3 как конечный результат и возвращает его из useState.
// Вот почему нажатие «+3» в приведенном выше примере корректно увеличивает значение на 3.

//# Что произойдет, если вы обновите состояние после его замены
// А как насчет этого обработчика событий? Как вы думаете, какое значение number будет в следующем рендере?

import { useState } from 'react';

function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 5);
          setNumber(n => n + 1);
        }}
      >
        Increase the number
      </button>
    </>
  );
}

/* Вот что этот обработчик событий говорит React:
1. setNumber(number + 5): number есть 0, значит setNumber(0 + 5). React добавляет «заменить на 5» в свою очередь.
2. setNumber(n => n + 1): n => n + 1 это функция обновления. React добавляет эту функцию в свою очередь.
*/

/* Во время следующего рендера React проходит через очередь состояний:

обновление в очереди	n	                   возвращается
заменить на 5	        0(неиспользованный)	 5
n => n + 1	          5	                   5 + 1 = 6
*/

// React сохраняет 6 как конечный результат и возвращает его из useState.
//* Вы могли заметить, что setState(5) на самом деле работает как setState(n => 5), но n не используется!


