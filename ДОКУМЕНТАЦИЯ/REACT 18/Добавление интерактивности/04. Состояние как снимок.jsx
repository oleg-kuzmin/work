//# Состояние как снимок
// Переменные состояния могут выглядеть как обычные переменные JavaScript, которые вы можете читать и записывать. Однако состояние больше похоже на снимок. Его установка не изменяет уже имеющуюся у вас переменную состояния, а вместо этого запускает повторный рендеринг.

/* Вы выучите:
- Как настройка состояния вызывает повторный рендеринг
- Когда и как обновляется состояние
- Почему состояние не обновляется сразу после его установки
- Как обработчики событий получают доступ к «моментальному снимку» состояния
*/

//# Настройка триггеров состояния рендеринга
// Вы можете думать о своем пользовательском интерфейсе как об изменении непосредственно в ответ на пользовательское событие, такое как щелчок. В React это работает немного иначе, чем эта ментальная модель. На предыдущей странице вы видели, что состояние настройки запрашивает повторный рендеринг из React. Это означает, что для того, чтобы интерфейс отреагировал на событие, вам необходимо обновить состояние.

// В этом примере, когда вы нажимаете "send", setIsSent(true) указывает React повторно отобразить пользовательский интерфейс:

import { useState } from 'react';

function Form() {
  const [isSent, setIsSent] = useState(false);
  const [message, setMessage] = useState('Hi!');
  if (isSent) {
    return <h1>Your message is on its way!</h1>;
  }
  return (
    <form
      onSubmit={e => {
        e.preventDefault();
        setIsSent(true);
        sendMessage(message);
      }}
    >
      <textarea placeholder="Message" value={message} onChange={e => setMessage(e.target.value)} />
      <button type="submit">Send</button>
    </form>
  );
}

function sendMessage(message) {
  // ...
}

/*
Вот что происходит, когда вы нажимаете кнопку:
1. Выполняется обработчик события onSubmit.
2. setIsSent(true) устанавливает для isSent значение true и ставит в очередь новый рендеринг.
3. React повторно отображает компонент в соответствии с новым значением isSent.
*/

// Давайте подробнее рассмотрим взаимосвязь между состоянием и рендерингом.

//# Рендеринг делает моментальный снимок во времени
// Рендеринг означает, что React вызывает ваш компонент, который является функцией. JSX, который вы возвращаете из этой функции, подобен моментальному снимку пользовательского интерфейса во времени. Его реквизиты, обработчики событий и локальные переменные были рассчитаны с использованием его состояния во время рендеринга.

// В отличие от фотографии или кадра фильма, «моментальный снимок» пользовательского интерфейса, который вы возвращаете, является интерактивным. Он включает в себя логику, такую как обработчики событий, которые определяют, что происходит в ответ на входные данные. React обновляет экран в соответствии с этим снимком и подключает обработчики событий. В результате нажатие кнопки вызовет обработчик кликов из вашего JSX.

/* Когда React перерисовывает компонент:
1. React снова вызывает вашу функцию.
2. Ваша функция возвращает новый снимок JSX.
3. Затем React обновляет экран в соответствии со снимком, который вы вернули.
*/

// Как память компонента, состояние не похоже на обычную переменную, которая исчезает после возврата из вашей функции. Состояние на самом деле «живет» в самом React — как будто на полке! — вне вашей функции. Когда React вызывает ваш компонент, он дает вам снимок состояния для этого конкретного рендеринга. Ваш компонент возвращает снимок пользовательского интерфейса со свежим набором реквизитов и обработчиков событий в своем JSX, и все они рассчитаны с использованием значений состояния из этого рендеринга!

// Вот небольшой эксперимент, чтобы показать вам, как это работает. В этом примере вы можете ожидать, что нажатие кнопки «+3» увеличит счетчик три раза, потому что он вызывает setNumber(number + 1) три раза.

// Посмотрите, что происходит, когда вы нажимаете кнопку «+3»:

import { useState } from 'react';

function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 1);
          setNumber(number + 1);
          setNumber(number + 1);
        }}
      >
        +3
      </button>
    </>
  );
}

// Обратите внимание, что число увеличивается только один раз за клик!

// Состояние настройки изменяет его только для следующего рендера. Во время первого рендеринга число было равно 0. Вот почему в обработчике onClick этого рендеринга значение числа по-прежнему равно 0 даже после вызова setNumber(number + 1):

/* Вот что обработчик нажатия этой кнопки сообщает React:

1. setNumber (number + 1): number равно 0, поэтому setNumber (0 + 1)
- React готовится изменить number на 1 при следующем рендеринге.

2. setNumber (number + 1): number равно 0, поэтому setNumber (0 + 1)
- React готовится изменить number на 1 при следующем рендеринге.

3. setNumber (number + 1): number равно 0, поэтому setNumber (0 + 1)
- React готовится изменить number на 1 при следующем рендеринге.
*/

// Несмотря на то, что вы вызвали setNumber(number + 1) три раза, в этом рендере обработчик событий number всегда равен 0, поэтому вы устанавливаете состояние 1 три раза. Вот почему после завершения обработчика событий React повторно отображает компонент с number равным 1, а не с 3.

// Вы также можете визуализировать это, мысленно заменяя переменные состояния их значениями в своем коде. Поскольку number переменная состояния предназначена 0 для этого рендера, его обработчик событий выглядит так:

<button
  onClick={() => {
    setNumber(0 + 1);
    setNumber(0 + 1);
    setNumber(0 + 1);
  }}
>
  +3
</button>;

// Для следующего рендера number равен 1, так что обработчик щелчка рендера выглядит так:

<button
  onClick={() => {
    setNumber(1 + 1);
    setNumber(1 + 1);
    setNumber(1 + 1);
  }}
>
  +3
</button>;

// Вот почему повторное нажатие на кнопку установит счетчик на 2, затем 3 на следующий щелчок и так далее.

//# Состояние с течением времени
