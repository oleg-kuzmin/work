//# Реагирование на события
// React позволяет добавлять обработчики событий в ваш JSX. Обработчики событий — это ваши собственные функции, которые будут запускаться в ответ на такие действия, как щелчок, наведение курсора, фокусировка ввода формы и т. д.

/* Вы выучите:
- Различные способы написания обработчика событий
- Как передать логику обработки событий из родительского компонента
- Как распространяются события и как их остановить
*/

//# Добавление обработчиков событий
// Чтобы добавить обработчик событий, сначала определите функцию, а затем передайте ее в качестве свойства соответствующему тегу JSX. Например, вот кнопка, которая еще ничего не делает:

function Button() {
  return <button>I don't do anything</button>;
}

/* Вы можете заставить его показывать сообщение, когда пользователь нажимает, выполнив следующие три шага:
1. Объявите функцию, вызываемую handleClick внутри вашего Button компонента.
2. Реализуйте логику внутри этой функции (используйте alert для отображения сообщения).
3. Добавьте onClick={handleClick} в <button> JSX.
*/

function Button() {
  function handleClick() {
    alert('You clicked me!');
  }

  return <button onClick={handleClick}>Click me</button>;
}

/* Вы определили handleClick функцию, а затем передали ее в качестве props <button>.
handleClick является обработчиком событий.

Функции обработчика событий:
- Обычно определяются внутри ваших компонентов.
- Имеют имена, начинающиеся с handle, за которыми следует название события.
*/

// По соглашению принято именовать обработчики событий - handle, за которыми следует имя события. Вы часто будете видеть onClick={handleClick}, onMouseEnter={handleMouseEnter} и так далее.

// В качестве альтернативы вы можете определить встроенный обработчик событий в JSX:
function Button() {
  return (
    <button
      onClick={function handleClick() {
        alert('You clicked me!');
      }}
    >
      Click me
    </button>
  );
}

// Или, более кратко, используя функцию стрелки:
function Button() {
  return (
    <button
      onClick={() => {
        alert('You clicked me!');
      }}
    >
      Click me
    </button>
  );
}

// Все эти стили эквивалентны. Встроенные обработчики событий удобны для коротких функций.

//* Примечание
// Функции, передаваемые обработчикам событий, должны передаваться, а не вызываться. Например:

// передача функции (правильно) - <button onClick={handleClick}>
// вызов функции (неверно) - <button onClick={handleClick()}>

// Разница тонкая. В первом примере handleClick функция передается как onClick обработчик события. Это говорит React запомнить это и вызывать вашу функцию только тогда, когда пользователь нажимает кнопку.

// Во втором примере handleClick() запускает функцию сразу во время рендеринга, без каких-либо кликов. Это потому, что JavaScript внутри JSX и фигурных скобок {} выполняется сразу.

// Когда вы пишете встроенный код, та же ловушка проявляется по-другому:

// передача функции (правильно) - <button onClick={() => alert('...')}>
// вызов функции (неверно) - <button onClick={alert('...')}>

// Такой встроенный код не будет срабатывать по клику — он срабатывает каждый раз, когда компонент отрисовывается:

// This alert fires when the component renders, not when clicked!
<button onClick={alert('You clicked me!')} />;

// Если вы хотите определить встроенный обработчик событий, оберните его в анонимную функцию следующим образом:
<button onClick={() => alert('You clicked me!')} />;

// Вместо выполнения кода внутри при каждом рендеринге создается функция, которая будет вызываться позже.

// В итоге передеавать функцию нужно так:

// <button onClick={handleClick} />
// или
// <button onClick={() => alert('...')} />

//# Чтение свойств в обработчиках событий
