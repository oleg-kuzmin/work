//# Состояние: память компонента
// Компонентам часто необходимо изменить то, что отображается на экране в результате взаимодействия. Ввод в форму должен обновить поле ввода, нажатие «Далее» на карусели изображений должно изменить отображаемое изображение, нажатие «купить» должно поместить продукт в корзину. Компоненты должны «запоминать» вещи: текущее входное значение, текущее изображение, корзину. В React такой тип памяти для конкретного компонента называется состоянием.

/* Вы выучите:
- Как добавить переменную состояния с помощью хука useState
- Какую пару значений возвращает хук useState
- Как добавить более одной переменной состояния
- Почему состояние называется локальным
*/

//# Когда обычной переменной недостаточно
// Вот компонент, который рендерит изображение скульптуры. Нажатие кнопки «Далее» должно отобразить следующую скульптуру, изменив индекс на 1, затем на 2 и так далее. Однако это не сработает (вы можете попробовать!):

const sculptureList = [
  {
    name: 'Homenaje a la Neurocirugía',
    artist: 'Marta Colvin Andrade',
    description:
      'Although Colvin is predominantly known for abstract themes that allude to pre-Hispanic symbols, this gigantic sculpture, an homage to neurosurgery, is one of her most recognizable public art pieces.',
    url: 'https://i.imgur.com/Mx7dA2Y.jpg',
    alt: 'A bronze statue of two crossed hands delicately holding a human brain in their fingertips.',
  },
  {
    name: 'Floralis Genérica',
    artist: 'Eduardo Catalano',
    description:
      'This enormous (75 ft. or 23m) silver flower is located in Buenos Aires. It is designed to move, closing its petals in the evening or when strong winds blow and opening them in the morning.',
    url: 'https://i.imgur.com/ZF6s192m.jpg',
    alt: 'A gigantic metallic flower sculpture with reflective mirror-like petals and strong stamens.',
  },
];

function Gallery() {
  let index = 0;

  function handleClick() {
    index = index + 1;
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleClick}>Next</button>
      <h2>
        <i>{sculpture.name} </i>
        by {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} of {sculptureList.length})
      </h3>
      <img src={sculpture.url} alt={sculpture.alt} />
      <p>{sculpture.description}</p>
    </>
  );
}

/*
Обработчик события handleClick обновляет локальную переменную index.
Но две вещи препятствуют тому, чтобы это изменение было видимым:
1. Локальные переменные не сохраняются между рендерами. Когда React рендерит этот компонент во второй раз, он рендерит его с нуля — он не учитывает никаких изменений в локальных переменных.
2. Изменения локальных переменных не вызовут рендеринга. React не понимает, что ему нужно снова отрендерить компонент с новыми данными.
*/

/* Чтобы обновить компонент новыми данными, должны произойти две вещи:
1. Сохранение данные между рендерами.
2. Запуск React для рендеринга компонента с новыми данными (повторный рендеринг).
*/

/* Хук useState предоставляет две вещи:
1. Переменная состояния для сохранения данных между рендерами.
2. Функция установки состояния для обновления переменной и запуска React для повторного рендеринга компонента.
*/

//# Добавление переменной состояния
// Чтобы добавить переменную состояния, импортируйте useState из React в начало файла:

import { useState } from 'react';

// Затем замените строку let index = 0 на const [index, setIndex] = useState(0);

// index — это переменная состояния, а setIndex — функция установки.

// Синтаксис [] здесь называется деструктурированием массива и позволяет считывать значения из массива. Массив, возвращаемый useState, всегда содержит ровно два элемента.

// Вот как они работают вместе в handleClick:

function handleClick() {
  setIndex(index + 1);
}

// Теперь нажатие кнопки «Далее» переключает текущую скульптуру:

import { useState } from 'react';
import { sculptureList } from './data.js';

export default function Gallery() {
  const [index, setIndex] = useState(0);

  function handleClick() {
    setIndex(index + 1);
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleClick}>Next</button>
      <h2>
        <i>{sculpture.name} </i>
        by {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} of {sculptureList.length})
      </h3>
      <img src={sculpture.url} alt={sculpture.alt} />
      <p>{sculpture.description}</p>
    </>
  );
}

//# Встречайте свой первый хук
// В React useState, как и любая другая функция, начинающаяся с «use», называется хуком.

// Хуки — это специальные функции, которые доступны только во время рендеринга React (о чем мы поговорим подробнее на следующей странице). Они позволяют вам «подключаться» к различным функциям React.

// Состояние — это только одна из этих функций, но позже вы познакомитесь с другими хуками.

//* Важно
// Хуки — функции, начинающиеся с use — могут вызываться только на верхнем уровне ваших компонентов или ваших собственных хуков. Вы не можете вызывать хуки внутри условий, циклов или других вложенных функций. Хуки — это функции, но полезно думать о них как о безусловных декларациях о потребностях вашего компонента. Вы «используете» функции React в верхней части вашего компонента, подобно тому, как вы «импортируете» модули в верхней части вашего файла.

//# Анатомия useState
/*
Когда вы вызываете useState, вы сообщаете React, что хотите, чтобы этот компонент что-то запомнил:
const [index, setIndex] = useState(0);
*/

// В этом случае вы хотите, чтобы React помнил index.

//* Заметка
// По соглашению эта пара именуется как const [something, setSomething]. Вы можете назвать это как угодно, но соглашения облегчают понимание разных проектов.

// Единственный аргумент useState — это начальное значение вашей переменной состояния. В этом примере начальное значение индекса устанавливается равным 0 с помощью useState(0).

/* Каждый раз, когда ваш компонент рендерится, useState предоставляет вам массив, содержащий два значения:
1. Переменная состояния (index) со значением, которое вы сохранили.
2. Функция установки состояния (setIndex), которая может обновлять переменную состояния и запускать React для повторного рендеринга компонента.
*/

/*
Вот как это происходит в действии:
const [index, setIndex] = useState(0);

1. Ваш компонент отображается в первый раз. Поскольку вы передали 0 в useState в качестве начального значения для индекса, он вернет [0, setIndex]. React помнит, что 0 — это последнее значение состояния.
2. Вы обновляете состояние. Когда пользователь нажимает кнопку, он вызывает setIndex(index + 1). index равен 0, поэтому это setIndex(1). Это говорит React помнить, что индекс теперь равен 1, и запускает другой рендеринг.
3. Второй рендер вашего компонента. React по-прежнему видит useState(0), но поскольку React запоминает, что вы установили индекс равным 1, вместо этого он возвращает [1, setIndex].
4. И так далее!
*/

//# Предоставление компоненту нескольких переменных состояния
