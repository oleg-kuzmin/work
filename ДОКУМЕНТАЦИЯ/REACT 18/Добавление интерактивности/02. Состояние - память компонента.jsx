//# Состояние: память компонента
// Компонентам часто необходимо изменить то, что отображается на экране в результате взаимодействия. Ввод в форму должен обновить поле ввода, нажатие «Далее» на карусели изображений должно изменить отображаемое изображение, нажатие «купить» должно поместить продукт в корзину. Компоненты должны «запоминать» вещи: текущее входное значение, текущее изображение, корзину. В React такой тип памяти для конкретного компонента называется состоянием.

/* Вы выучите:
- Как добавить переменную состояния с помощью хука useState
- Какую пару значений возвращает хук useState
- Как добавить более одной переменной состояния
- Почему состояние называется локальным
*/

//# Когда обычной переменной недостаточно
// Вот компонент, который рендерит изображение скульптуры. Нажатие кнопки «Далее» должно отобразить следующую скульптуру, изменив индекс на 1, затем на 2 и так далее. Однако это не сработает (вы можете попробовать!):

const sculptureList = [
  {
    name: 'Homenaje a la Neurocirugía',
    artist: 'Marta Colvin Andrade',
    description:
      'Although Colvin is predominantly known for abstract themes that allude to pre-Hispanic symbols, this gigantic sculpture, an homage to neurosurgery, is one of her most recognizable public art pieces.',
    url: 'https://i.imgur.com/Mx7dA2Y.jpg',
    alt: 'A bronze statue of two crossed hands delicately holding a human brain in their fingertips.',
  },
  {
    name: 'Floralis Genérica',
    artist: 'Eduardo Catalano',
    description:
      'This enormous (75 ft. or 23m) silver flower is located in Buenos Aires. It is designed to move, closing its petals in the evening or when strong winds blow and opening them in the morning.',
    url: 'https://i.imgur.com/ZF6s192m.jpg',
    alt: 'A gigantic metallic flower sculpture with reflective mirror-like petals and strong stamens.',
  },
];

function Gallery() {
  let index = 0;

  function handleClick() {
    index = index + 1;
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleClick}>Next</button>
      <h2>
        <i>{sculpture.name} </i>
        by {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} of {sculptureList.length})
      </h3>
      <img src={sculpture.url} alt={sculpture.alt} />
      <p>{sculpture.description}</p>
    </>
  );
}

/*
Обработчик события handleClick обновляет локальную переменную index.
Но две вещи препятствуют тому, чтобы это изменение было видимым:
1. Локальные переменные не сохраняются между рендерами. Когда React рендерит этот компонент во второй раз, он рендерит его с нуля — он не учитывает никаких изменений в локальных переменных.
2. Изменения локальных переменных не вызовут рендеринга. React не понимает, что ему нужно снова отрендерить компонент с новыми данными.
*/

/* Чтобы обновить компонент новыми данными, должны произойти две вещи:
1. Сохранение данные между рендерами.
2. Запуск React для рендеринга компонента с новыми данными (повторный рендеринг).
*/

/* Хук useState предоставляет две вещи:
1. Переменная состояния для сохранения данных между рендерами.
2. Функция установки состояния для обновления переменной и запуска React для повторного рендеринга компонента.
*/

//# Добавление переменной состояния
// Чтобы добавить переменную состояния, импортируйте useState из React в начало файла:

import { useState } from 'react';

// Затем замените строку let index = 0 на const [index, setIndex] = useState(0);

// index — это переменная состояния, а setIndex — функция установки.

// Синтаксис [] здесь называется деструктурированием массива и позволяет считывать значения из массива. Массив, возвращаемый useState, всегда содержит ровно два элемента.

// Вот как они работают вместе в handleClick:

function handleClick() {
  setIndex(index + 1);
}

// Теперь нажатие кнопки «Далее» переключает текущую скульптуру:

import { useState } from 'react';
import { sculptureList } from './data.js';

export default function Gallery() {
  const [index, setIndex] = useState(0);

  function handleClick() {
    setIndex(index + 1);
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleClick}>Next</button>
      <h2>
        <i>{sculpture.name} </i>
        by {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} of {sculptureList.length})
      </h3>
      <img src={sculpture.url} alt={sculpture.alt} />
      <p>{sculpture.description}</p>
    </>
  );
}

//# Встречайте свой первый хук
// В React useState, как и любая другая функция, начинающаяся с «use», называется хуком.

// Хуки — это специальные функции, которые доступны только во время рендеринга React (о чем мы поговорим подробнее на следующей странице). Они позволяют вам «подключаться» к различным функциям React.

// Состояние — это только одна из этих функций, но позже вы познакомитесь с другими хуками.

//* Важно
// Хуки — функции, начинающиеся с use — могут вызываться только на верхнем уровне ваших компонентов или ваших собственных хуков. Вы не можете вызывать хуки внутри условий, циклов или других вложенных функций. Хуки — это функции, но полезно думать о них как о безусловных декларациях о потребностях вашего компонента. Вы «используете» функции React в верхней части вашего компонента, подобно тому, как вы «импортируете» модули в верхней части вашего файла.

//# Анатомия useState
/*
Когда вы вызываете useState, вы сообщаете React, что хотите, чтобы этот компонент что-то запомнил:
const [index, setIndex] = useState(0);
*/

// В этом случае вы хотите, чтобы React помнил index.

//* Заметка
// По соглашению эта пара именуется как const [something, setSomething]. Вы можете назвать это как угодно, но соглашения облегчают понимание разных проектов.

// Единственный аргумент useState — это начальное значение вашей переменной состояния. В этом примере начальное значение индекса устанавливается равным 0 с помощью useState(0).

/* Каждый раз, когда ваш компонент рендерится, useState предоставляет вам массив, содержащий два значения:
1. Переменная состояния (index) со значением, которое вы сохранили.
2. Функция установки состояния (setIndex), которая может обновлять переменную состояния и запускать React для повторного рендеринга компонента.
*/

/*
Вот как это происходит в действии:
const [index, setIndex] = useState(0);

1. Ваш компонент отображается в первый раз. Поскольку вы передали 0 в useState в качестве начального значения для индекса, он вернет [0, setIndex]. React помнит, что 0 — это последнее значение состояния.
2. Вы обновляете состояние. Когда пользователь нажимает кнопку, он вызывает setIndex(index + 1). index равен 0, поэтому это setIndex(1). Это говорит React помнить, что индекс теперь равен 1, и запускает другой рендеринг.
3. Второй рендер вашего компонента. React по-прежнему видит useState(0), но поскольку React запоминает, что вы установили индекс равным 1, вместо этого он возвращает [1, setIndex].
4. И так далее!
*/

//# Предоставление компоненту нескольких переменных состояния
// В одном компоненте вы можете иметь столько переменных состояния любого типа, сколько захотите. Этот компонент имеет две переменные состояния, числовой index и логическое значение showMore, которое переключается, когда вы нажимаете «Показать подробности»:

function Gallery() {
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);

  function handleNextClick() {
    setIndex(index + 1);
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleNextClick}>Next</button>
      <h2>
        <i>{sculpture.name} </i>
        by {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} of {sculptureList.length})
      </h3>
      <button onClick={handleMoreClick}>{showMore ? 'Hide' : 'Show'} details</button>
      {showMore && <p>{sculpture.description}</p>}
      <img src={sculpture.url} alt={sculpture.alt} />
    </>
  );
}

// Рекомендуется иметь несколько переменных состояния, если их состояние не связано, например index и showMore в этом примере. Но если вы обнаружите, что часто меняете две переменные состояния вместе, может быть проще объединить их в одну. Например, если у вас есть форма с множеством полей, удобнее иметь одну переменную состояния, которая содержит объект, чем переменную состояния для каждого поля. Дополнительные советы см. в разделе Выбор структуры состояния.

//* Как React узнает, какое состояние вернуть?
// Вы могли заметить, что вызов useState не получает никакой информации о том, на какую переменную состояния он ссылается. В useState не передается «идентификатор», так как же он узнает, какую из переменных состояния следует вернуть? Полагается ли это на какое-то волшебство, такое как разбор ваших функций? Ответ - нет.

// Вместо этого, чтобы обеспечить лаконичный синтаксис, хуки полагаются на стабильный порядок вызовов при каждом рендеринге одного и того же компонента. Это хорошо работает на практике, потому что если вы будете следовать правилу выше («вызывать хуки только на верхнем уровне»), хуки всегда будут вызываться в одном и том же порядке. Кроме того, плагин linter отлавливает большинство ошибок.

// Внутри React хранит массив пар состояний для каждого компонента. Он также поддерживает текущий индекс пары, который перед рендерингом устанавливается равным 0. Каждый раз, когда вы вызываете useState, React предоставляет вам следующую пару состояний и увеличивает индекс.

// Вам не нужно понимать это, чтобы использовать React, но вы можете найти полезную ментальную модель.

//# Состояние изолированное и приватное
// Состояние является локальным для экземпляра компонента на экране. Другими словами, если вы рендерите один и тот же компонент дважды, каждая копия будет иметь полностью изолированное состояние! Изменение одного из них не повлияет на другой.

// В этом примере ранее компонент Gallery рендерится дважды без каких-либо изменений в его логике. Попробуйте нажать кнопки внутри каждой из Gallery. Обратите внимание, что их состояние независимо:

function Page() {
  return (
    <div className="Page">
      <Gallery />
      <Gallery />
    </div>
  );
}

// Это то, что отличает состояние от обычных переменных, которые вы можете объявить в верхней части вашего модуля. Состояние не привязано к конкретному вызову функции или месту в коде, оно «локально» для определенного места на экране. Вы отобразили два <Gallery/> компонента, поэтому их состояние сохраняется отдельно.

// Также обратите внимание, что компонент Page ничего не «знает» о состоянии Gallery или даже о том, есть ли оно у него. В отличие от свойств, состояние полностью приватно для компонента, объявляющего его. Родительский компонент не может его изменить. Это позволяет добавлять состояние к любому компоненту или удалять его, не затрагивая остальные компоненты.

// Что, если вы хотите, чтобы обе Gallery синхронизировали свои состояния? Правильный способ сделать это в React — удалить состояние из дочерних компонентов и добавить его к их ближайшему общему родителю. Следующие несколько страниц будут посвящены организации состояния одного компонента, но мы вернемся к этой теме в разделе «Обмен состояниями между компонентами».

//# Резюме
/*
- Используйте переменную состояния, когда компоненту необходимо «запомнить» некоторую информацию между рендерами.
- Переменные состояния объявляются путем вызова метода useStateHook.
- Хуки — это специальные функции, начинающиеся с use. Они позволяют вам «подключаться» к функциям React, таким как состояние.
- Хуки могут напомнить вам об импорте: их нужно вызывать безоговорочно. Вызов хуков, включая useState, допустим только на верхнем - уровне компонента или другого хука.
- Хук useState возвращает массив из пары значений: текущее состояние и функцию для его обновления.
- Вы можете иметь более одной переменной состояния. Внутри React сопоставляет их по порядку.
- Состояние является частным для компонента. Если вы визуализируете его в двух местах, каждая копия получает свое состояние.
*/
