//# Передача реквизита в компонент
// Компоненты React используют реквизиты для взаимодействия друг с другом. Каждый родительский компонент может передавать некоторую информацию своим дочерним компонентам, передав им реквизиты. Свойства могут напоминать вам атрибуты HTML, но через них можно передавать любые значения JavaScript, включая объекты, массивы и функции.

/*
Ты выучишь:
- Как передать реквизиты компоненту
- Как читать реквизиты из компонента
- Как указать значения по умолчанию для реквизита
- Как передать JSX компоненту
- Как реквизит меняется со временем
*/

//# Знакомый реквизит
// Реквизит — это информация, которую вы передаете в тег JSX. Например, className, src, alt, width, height - некоторые из реквизитов, которые вы можете передать в <img>.

function Avatar() {
  return <img className="avatar" src="https://i.imgur.com/1bX5QH6.jpg" alt="Lin Lanying" width={100} height={100} />;
}

function Profile() {
  return <Avatar />;
}

// Свойства, которые вы можете передать в тег <img>, предопределены (ReactDOM соответствует стандарту HTML). Но вы можете передать любые реквизиты своим собственным компонентам, например <Avatar>, чтобы настроить их. Вот как!

//# Передача реквизита в компонент
// В этом коде компонент Profile не передает никаких реквизитов своему дочернему компоненту Avatar:
function Profile() {
  return <Avatar />;
}

// Вы можете передать в Avatar реквизит в два этапа.

//* Шаг 1. Передайте реквизиты дочернему компоненту.
// Сначала передайте некоторые реквизиты в Avatar. Например, давайте передадим два реквизита: person(объект) и size(число):
function Profile() {
  return <Avatar person={{ name: 'Lin Lanying', imageId: '1bX5QH6' }} size={100} />;
}

//* Примечание
// Если в person= вас смутили двойные фигурные скобки, помните, что это всего лишь объект внутри фигурных скобок JSX.
//* Примечание

// Теперь вы можете прочитать эти реквизиты внутри компонента Avatar.

//* Шаг 2. Прочтите реквизиты внутри дочернего компонента.
// Вы можете прочитать эти реквизиты, указав их имена - person, size, разделенные запятыми, внутри скобок сразу после function Avatar ({person, size}). Это позволяет использовать их внутри кода Avatar, как если бы вы использовали переменные (деструктуризация объекта).

function Avatar({ person, size }) {
  // person and size are available here
}

// Добавьте немного логики Avatar, которая использует реквизиты person и size для рендеринга, и все готово.

// Теперь вы можете настроить рендеринг Avatar разными способами с разными реквизитами.

//* utils.js
function getImageUrl(person, size = 's') {
  return 'https://i.imgur.com/' + person.imageId + size + '.jpg';
}

//* App.js
function Avatar({ person, size }) {
  return <img className="avatar" src={getImageUrl(person)} alt={person.name} width={size} height={size} />;
}

function Profile() {
  return (
    <div>
      <Avatar
        size={100}
        person={{
          name: 'Katsuko Saruhashi',
          imageId: 'YfeOqp2',
        }}
      />
      <Avatar
        size={80}
        person={{
          name: 'Aklilu Lemma',
          imageId: 'OKS67lh',
        }}
      />
      <Avatar
        size={50}
        person={{
          name: 'Lin Lanying',
          imageId: '1bX5QH6',
        }}
      />
    </div>
  );
}

// Реквизиты позволяют вам думать о родительских и дочерних компонентах независимо. Например, вы можете изменить внутренний реквизит person или size внутри Profile, не задумываясь о том, как их использует Avatar. Аналогично вы можете изменить то, как Avatar использует эти реквизиты, не заглядывая в файл Profile.

// Вы можете думать о реквизите как о «ручках», которые можно регулировать. Они выполняют ту же роль, что и аргументы для функций — фактически реквизиты являются единственным аргументом вашего компонента! Функции компонента React принимают один аргумент — объект props:

function Avatar(props) {
  let person = props.person;
  let size = props.size;
  // ...
}

// Обычно вам не нужен весь объект props целиком, поэтому вы разбиваете его на отдельные реквизиты.

//! ловушка
// Не пропустите пару скобок {} внутри () при объявлении реквизита:
function Avatar({ person, size }) {
  // ...
}

// Этот синтаксис называется «деструктуризацией» и эквивалентен чтению свойств из параметра функции:
function Avatar(props) {
  let person = props.person;
  let size = props.size;
  // ...
}
//! ловушка

//# Указание значения по умолчанию для свойства
// Если вы хотите дать свойству значение по умолчанию, к которому можно будет вернуться, когда значение не указано, вы можете сделать это с помощью деструктуризации, поставив знак "=значение по умолчанию" сразу после параметра:

function Avatar({ person, size = 100 }) {
  // ...
}

// Теперь, если <Avatar person={...} /> рендерится без реквизита size, для параметра size будет установлено значение 100.

// Значение по умолчанию используется только в том случае, если свойство size отсутствует или если вы передаете size={undefined}. Но если вы передадите size={null} или size={0}, значение по умолчанию не будет использоваться.

//# Пересылка реквизитов с помощью синтаксиса распространения JSX
// Иногда передача реквизита становится очень повторяющейся:

function Profile({ person, size, isSepia, thickBorder }) {
  return (
    <div className="card">
      <Avatar person={person} size={size} isSepia={isSepia} thickBorder={thickBorder} />
    </div>
  );
}

// В повторяющемся коде нет ничего плохого — он может быть более разборчивым. Но иногда вы можете ценить краткость. Некоторые компоненты пересылают все свои реквизиты своим дочерним элементам, как этот Profile работает с Avatar. Поскольку они не используют ни один из своих реквизитов напрямую, имеет смысл использовать более краткий синтаксис «распространения»:

function Profile(props) {
  return (
    <div className="card">
      <Avatar {...props} />
    </div>
  );
}

// Это перенаправит все реквизиты Profile в Avatar без перечисления каждого из них.

// Используйте синтаксис распространения сдержанно. Если вы используете его в любом другом компоненте, что-то не так. Часто это означает, что вам следует разделить компоненты и передать дочерние элементы как JSX. Подробнее об этом дальше!

//# Передача JSX как детей